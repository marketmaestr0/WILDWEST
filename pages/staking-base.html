<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BASE STAKING</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

    <link rel="stylesheet" href="../css/styles.css">

    
    <style>
        :root {
            /* Submarine/Metallic Color Palette */
            --primary-bg: #0d1117;
            --secondary-bg: #161b22;
            --accent-bg: #21262d;
            --card-bg: linear-gradient(145deg, #1c2128 0%, #30363d  50%, #21262d 100%);
            --metallic-bg: linear-gradient(145deg, #2d3748 0%, #4a5568 50%, #2d3748 100%);
            --submarine-metal: linear-gradient(145deg, #2c5530 0%, #68d391 25%, #38a169 50%, #2c5530 100%);
            --console-metal: linear-gradient(145deg, #4a5568 0%, #718096 50%, #4a5568 100%);
            
            /* Text Colors */
            --primary-text: #f0f6fc;
            --secondary-text: #7d8590;
            --accent-text: #58a6ff;
            --success-text: #00d4ff;
            --warning-text: #f85149;
            
            /* Interactive Colors */
            --accent-color: #58a6ff;
            --success-color: #0099cc;
            --warning-color: #da3633;
            --error-color: #f85149;
            --console-blue: #00d4ff;
            --console-amber: #ffbf00;
            --console-red: #ff073a;
            
            /* Effects */
            --metallic-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            --button-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            --console-glow: 0 0 20px rgba(0, 212, 255, 0.4);
            --border-radius: 8px;
            --button-radius: 50%;
            
            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', 'Roboto Mono', 'SF Mono', Monaco, Inconsolata, 'Roboto Mono', monospace;
            background: 
                radial-gradient(circle at 25% 25%, #1e3a3a 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, #2d4a4a 0%, transparent 50%),
                linear-gradient(135deg, #0d1117 0%, #161b22 25%, #21262d 50%, #0d1117 100%);
            background-attachment: fixed;
            background-size: 100% 100%;
            color: var(--primary-text);
            line-height: 1.4;
            overflow-x: hidden;
            font-size: 14px;
            font-weight: 400;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            position: relative;
            letter-spacing: 0.5px;
        }
        
        /* Submarine Console Background Effects */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 15% 25%, rgba(0, 212, 255, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 85% 75%, rgba(255, 191, 0, 0.06) 0%, transparent 45%),
                radial-gradient(circle at 50% 50%, rgba(88, 166, 255, 0.04) 0%, transparent 60%),
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 49px,
                    rgba(0, 212, 255, 0.03) 50px,
                    rgba(0, 212, 255, 0.03) 51px
                ),
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 49px,
                    rgba(88, 166, 255, 0.02) 50px,
                    rgba(88, 166, 255, 0.02) 51px
                );
            pointer-events: none;
            z-index: 0;
            animation: scanLines 8s ease-in-out infinite alternate;
        }
        
        /* Metallic Texture Overlay */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(1px 1px at 20px 20px, rgba(255,255,255,0.05), transparent),
                radial-gradient(1px 1px at 60px 60px, rgba(0, 212, 255, 0.03), transparent),
                radial-gradient(0.5px 0.5px at 100px 40px, rgba(255, 191, 0, 0.02), transparent),
                linear-gradient(45deg, transparent 48%, rgba(255,255,255,0.01) 49%, rgba(255,255,255,0.01) 51%, transparent 52%);
            background-repeat: repeat;
            background-size: 80px 80px, 120px 120px, 160px 160px, 4px 4px;
            animation: metallicShimmer 12s linear infinite;
            pointer-events: none;
            z-index: 0;
            opacity: 0.7;
        }
        
        @keyframes scanLines {
            0% { opacity: 0.6; }
            50% { opacity: 0.8; }
            100% { opacity: 0.6; }
        }
        
        @keyframes metallicShimmer {
            0% { transform: translateX(0px) translateY(0px); }
            25% { transform: translateX(-10px) translateY(5px); }
            50% { transform: translateX(10px) translateY(-5px); }
            75% { transform: translateX(-5px) translateY(-10px); }
            100% { transform: translateX(0px) translateY(0px); }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--spacing-lg) var(--spacing-md);
            min-height: 100vh;
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .hero-section {
            text-align: center;
            margin-bottom: var(--spacing-xl);
            position: relative;
            z-index: 2;
            width: 100%;
            max-width: 900px;
            padding: var(--spacing-xl);
            background: var(--metallic-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--metallic-shadow);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .hero-title {
            font-family: 'Orbitron', monospace;
            font-size: 3.5rem;
            font-weight: 900;
            color: #ffffff;
            margin-bottom: var(--spacing-lg);
            text-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.5),
                0 0 8px rgba(0, 212, 255, 0.3);
            letter-spacing: 3px;
            text-transform: uppercase;
            position: relative;
        }

        .hero-title::before {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 3px;
            background: linear-gradient(90deg, transparent, #00d4ff, transparent);
            border-radius: 2px;
        }
        
        .hero-subtitle {
            font-family: 'Roboto Mono', monospace;
            font-size: 1.2rem;
            color: var(--secondary-text);
            margin-bottom: var(--spacing-lg);
            font-weight: 400;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.5;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        @keyframes consoleGlow {
            0% { 
                background-position: 0% 50%; 
                text-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
            }
            50% { 
                background-position: 100% 50%; 
                text-shadow: 0 0 40px rgba(255, 191, 0, 0.4);
            }
            100% { 
                background-position: 0% 50%; 
                text-shadow: 0 0 30px rgba(88, 166, 255, 0.3);
            }
        }

        @keyframes blueGlow {
            0% { 
                text-shadow: 
                    0 0 15px var(--crt-blue),
                    0 0 25px var(--crt-blue),
                    0 0 35px var(--crt-blue),
                    0 0 50px rgba(0, 212, 255, 1);
            }
            100% { 
                text-shadow: 
                    0 0 15px var(--crt-blue),
                    0 0 25px var(--crt-blue),
                    0 0 35px var(--crt-blue),
                    0 0 50px rgba(0, 212, 255, 1);
            }
        }

        @keyframes subtleBlueGlow {
            0% { 
                text-shadow: 
                    0 0 5px var(--crt-blue),
                    0 0 10px rgba(0, 212, 255, 0.6),
                    0 0 15px rgba(0, 212, 255, 0.4);
            }
            100% { 
                text-shadow: 
                    0 0 8px var(--crt-blue),
                    0 0 12px rgba(0, 212, 255, 0.7),
                    0 0 20px rgba(0, 212, 255, 0.5);
            }
        }

        @keyframes epicBlueGlow {
            0% { 
                text-shadow: 
                    0 0 5px rgba(0, 212, 255, 0.8),
                    0 0 10px rgba(0, 212, 255, 0.6),
                    0 0 15px rgba(0, 212, 255, 0.4),
                    0 0 20px rgba(0, 212, 255, 0.3);
                transform: translateY(0px);
            }
            50% {
                text-shadow: 
                    0 0 8px rgba(0, 212, 255, 1),
                    0 0 15px rgba(0, 212, 255, 0.8),
                    0 0 25px rgba(0, 212, 255, 0.6),
                    0 0 35px rgba(0, 212, 255, 0.4);
                transform: translateY(-2px);
            }
            100% { 
                text-shadow: 
                    0 0 5px rgba(0, 212, 255, 0.8),
                    0 0 10px rgba(0, 212, 255, 0.6),
                    0 0 15px rgba(0, 212, 255, 0.4),
                    0 0 20px rgba(0, 212, 255, 0.3);
                transform: translateY(0px);
            }
        }

        @keyframes gradientShift {
            0%, 100% { 
                background-position: 0% 50%; 
            }
            25% { 
                background-position: 100% 50%; 
            }
            50% { 
                background-position: 50% 100%; 
            }
            75% { 
                background-position: 0% 100%; 
            }
        }
        
        /* Center all main content areas - Submarine Console Layout */
        .header, .stats-grid, .section, .tabs-container, .main-card {
            width: 100%;
            max-width: 900px;
            margin: 0 auto var(--spacing-xl) auto;
        }
        
        .contracts-grid {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--spacing-lg) 0;
        }
        
        /* Additional centering utilities */
        .text-center {
            text-align: center;
        }
        
        .flex-center {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .flex-col-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        /* Center form elements */
        .form-group {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            text-align: center;
        }
        
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            display: block;
        }
        
        /* Center contract cards */
        .contracts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            justify-items: center;
            padding: 20px 0;
        }
        
        
        /* Center stats grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            justify-items: center;
            text-align: center;
        }
        
        
        /* Submarine Console Tabs */
        .tabs {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-xl);
            padding: var(--spacing-sm);
            background: var(--metallic-bg);
            border-radius: var(--border-radius);
            border: 2px solid #2d3748;
            box-shadow: var(--metallic-shadow);
        }
        
        .tab-button {
            background: var(--console-metal);
            border: 2px solid #2d3748;
            color: var(--primary-text);
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: 4px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            min-width: 80px;
        }
        
        .tab-button::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            background: var(--console-amber);
            border-radius: 50%;
            opacity: 0.6;
        }
        
        .tab-button:hover,
        .tab-button.active {
            border-color: var(--console-green);
            background: rgba(57, 255, 20, 0.1);
            color: var(--console-green);
        }
        
        .tab-button:hover::before,
        .tab-button.active::before {
            background: var(--console-green);
            box-shadow: 0 0 8px var(--console-green);
            opacity: 1;
        }
        

        
        /* Center search controls */
        .search-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 30px;
            padding: 0 20px;
        }
        
        
        /* Center wallet section */
        .wallet-section {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .wallet-btn {
            margin: 0 auto;
            display: inline-block;
        }

        /* Back to Main Button */
        .back-btn {
            position: fixed;
            top: var(--spacing-lg);
            right: var(--spacing-lg);
            background: var(--console-metal);
            border: 2px solid #2d3748;
            color: var(--primary-text);
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--border-radius);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            min-width: 120px;
            box-shadow: var(--button-shadow);
            z-index: 1000;
        }
        
        .back-btn::before {
            content: 'â—„';
            font-size: 1rem;
            color: var(--console-green);
        }
        
        .back-btn:hover {
            transform: translateY(-1px);
            border-color: var(--console-green);
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 0 15px rgba(57, 255, 20, 0.3);
            color: var(--console-green);
        }
        
        .back-btn:hover::before {
            color: var(--console-green);
            text-shadow: 0 0 8px var(--console-green);
        }
        

        .header {
            text-align: center;
            padding: var(--spacing-xl) var(--spacing-lg);
            background: var(--metallic-bg);
            backdrop-filter: blur(15px);
            border-radius: var(--border-radius);
            border: 2px solid #2d3748;
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--metallic-shadow);
            position: relative;
            overflow: visible;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: var(--spacing-sm);
            left: var(--spacing-sm);
            width: 8px;
            height: 8px;
            background: var(--console-green);
            border-radius: 50%;
            box-shadow: 
                0 0 8px var(--console-green),
                0 0 16px var(--console-green);
            animation: consolePulse 2s ease-in-out infinite alternate;
        }
        
        @keyframes consolePulse {
            0% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        
        .header:hover {
            transform: translateY(-2px);
            border-color: var(--console-green);
            box-shadow: 
                var(--metallic-shadow),
                0 0 20px rgba(57, 255, 20, 0.2);
        }

        .header h1 {
            font-family: 'Orbitron', monospace;
            font-size: 2.2rem;
            font-weight: 900;
            color: var(--primary-text);
            margin-bottom: var(--spacing-sm);
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(57, 255, 20, 0.3);
        }

        .header p {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            color: var(--secondary-text);
            max-width: 500px;
            margin: 0 auto;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .wallet-section {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            flex-wrap: wrap;
        }

        /* Submarine Console Wallet Button */
        .wallet-btn {
            background: var(--console-metal);
            border: 3px solid #2d3748;
            color: var(--primary-text);
            padding: var(--spacing-md) var(--spacing-xl);
            border-radius: var(--border-radius);
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 160px;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            box-shadow: var(--button-shadow);
        }
        
        .wallet-btn::before {
            content: '';
            position: absolute;
            top: 8px;
            right: 8px;
            width: 6px;
            height: 6px;
            background: var(--console-green);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--console-green);
        }

        .wallet-btn:hover {
            transform: translateY(1px);
            border-color: var(--console-green);
            box-shadow: 
                var(--button-shadow),
                0 0 15px rgba(57, 255, 20, 0.3);
        }
        
        .wallet-btn:hover::before {
            box-shadow: 
                0 0 12px var(--console-green),
                0 0 20px var(--console-green);
        }

        .wallet-info {
            background: var(--accent-bg);
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: 20px;
            border: 1px solid var(--border-color);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        /* Wallet Modal Styles */
        .wallet-modal {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0, 0, 0, 0.9) !important;
            z-index: 99999 !important;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .wallet-modal-content {
            background: var(--bg-dark);
            border: 2px solid var(--crt-blue);
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 
                0 0 20px var(--crt-blue),
                inset 0 0 20px rgba(0, 212, 255, 0.1);
            position: relative;
            z-index: 100000;
        }

        .wallet-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .wallet-modal-header h3 {
            color: var(--crt-blue);
            font-family: 'Orbitron', monospace;
            font-size: 1.25rem;
            margin: 0;
            text-shadow: var(--crt-text-shadow);
        }

        .close-modal {
            background: none;
            border: none;
            color: var(--crt-blue);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-modal:hover {
            color: var(--accent-color);
            text-shadow: 0 0 10px var(--accent-color);
        }

        .mobile-notice {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--crt-blue);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            color: var(--crt-blue);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            text-align: center;
        }

        .wallet-options {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .wallet-option {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-primary);
            font-family: 'Roboto Mono', monospace;
        }

        .wallet-option:hover {
            border-color: var(--crt-blue);
            background: rgba(0, 212, 255, 0.05);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .wallet-name {
            font-weight: bold;
            color: var(--crt-blue);
            margin-bottom: 0.25rem;
        }

        .wallet-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .mobile-instructions {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        .mobile-instructions h4 {
            color: var(--crt-blue);
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            margin: 0 0 1rem 0;
            text-shadow: var(--crt-text-shadow);
        }

        .mobile-instructions ol {
            color: var(--text-secondary);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            padding-left: 1.25rem;
        }

        .mobile-instructions li {
            margin-bottom: 0.5rem;
        }

        .no-wallets-notice,
        .available-wallets-notice {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--crt-blue);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            color: var(--crt-blue);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            text-align: center;
        }

        .install-wallet {
            background: rgba(255, 165, 0, 0.1) !important;
            border-color: #ffa500 !important;
        }

        .install-wallet:hover {
            background: rgba(255, 165, 0, 0.2) !important;
            border-color: #ffa500 !important;
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.3) !important;
        }

        .install-wallet .wallet-name {
            color: #ffa500 !important;
        }

        /* Mobile-specific styles */
        .compatible-wallets {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        .compatible-wallets h4 {
            color: var(--crt-blue);
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            margin: 0 0 1rem 0;
            text-shadow: var(--crt-text-shadow);
        }

        .wallet-list-info {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .wallet-info-item {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            color: var(--text-primary);
            font-family: 'Roboto Mono', monospace;
        }

        .wallet-info-item .wallet-name {
            font-weight: bold;
            color: var(--crt-blue);
            margin-bottom: 0.25rem;
        }

        .wallet-info-item .wallet-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .copy-url-btn {
            background: var(--accent-color);
            border: none;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            color: white;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            margin-top: 0.5rem;
            transition: all 0.3s ease;
        }

        .copy-url-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .mobile-footer {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .mobile-footer strong {
            color: var(--crt-blue);
        }

        /* WW2 CRT Section Styling */
        .section {
            background: 
                linear-gradient(180deg, var(--crt-dark) 0%, var(--crt-background) 50%, var(--crt-dark) 100%),
                radial-gradient(ellipse at center, rgba(0, 212, 255, 0.05) 0%, transparent 70%);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            border: 2px solid var(--crt-blue-dim);
            text-align: center;
            box-shadow: 
                var(--metallic-shadow),
                inset 0 0 30px rgba(0, 212, 255, 0.1);
            position: relative;
        }
        
        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 4px,
                rgba(0, 212, 255, 0.02) 4px,
                rgba(0, 212, 255, 0.02) 8px
            );
            pointer-events: none;
            border-radius: var(--border-radius);
        }

        .section h2 {
            font-family: 'Roboto Mono', monospace;
            font-size: 1.3rem;
            margin-bottom: var(--spacing-md);
            color: var(--crt-blue-bright);
            font-weight: 700;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: var(--crt-glow);
            position: relative;
        }
        
        .section h2::before {
            content: '[ ';
            color: var(--crt-blue-dim);
        }
        
        .section h2::after {
            content: ' ]';
            color: var(--crt-blue-dim);
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            text-align: left;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            text-align: left;
        }

        .form-group label {
            font-family: 'Roboto Mono', monospace;
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
            color: var(--crt-blue-dim);
            text-align: left;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-shadow: 0 0 3px currentColor;
        }
        /* WW2 CRT Terminal Form Inputs */
        .form-input {
            background: 
                linear-gradient(180deg, var(--crt-dark) 0%, var(--crt-background) 100%);
            border: 2px solid var(--crt-blue-dim);
            border-radius: 2px;
            padding: var(--spacing-sm) var(--spacing-md);
            color: var(--crt-blue-bright);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            height: 40px;
            text-shadow: 0 0 5px currentColor;
            box-shadow: 
                inset 0 0 20px rgba(0, 212, 255, 0.1),
                0 0 5px rgba(0, 212, 255, 0.3);
        }
        
        .form-input::placeholder {
            color: var(--crt-blue-dim);
            text-shadow: 0 0 3px currentColor;
            font-family: 'Roboto Mono', monospace;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--crt-blue-bright);
            box-shadow: 
                inset 0 0 20px rgba(0, 212, 255, 0.2),
                0 0 0 1px var(--crt-blue-bright), 
                0 0 15px rgba(0, 212, 255, 0.5),
                0 0 25px rgba(0, 212, 255, 0.3);
            background: var(--crt-background);
            color: var(--crt-blue-bright);
            text-shadow: 0 0 8px currentColor;
        }
        
        /* CRT Typing Effect */
        .form-input:focus::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 18px;
            background: var(--crt-blue-bright);
            box-shadow: 0 0 5px currentColor;
            animation: cursor 1s infinite;
        }
        
        @keyframes cursor {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Submarine Console Button Styles */
        .btn {
            /* WW2 Submarine Console Button Base */
            background: var(--console-metal);
            border: 3px solid #2d3748;
            color: var(--primary-text);
            padding: 18px 24px;
            border-radius: var(--button-radius);
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            margin: var(--spacing-sm);
            min-width: 60px;
            min-height: 60px;
            white-space: nowrap;
            position: relative;
            overflow: visible;
            letter-spacing: 1px;
            text-transform: uppercase;
            text-align: center;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            
            /* Authentic submarine button styling */
            box-shadow: 
                var(--button-shadow),
                inset 0 -3px 0 #1a1f2e,
                inset 0 3px 0 rgba(255, 255, 255, 0.2),
                0 0 0 2px #2d3748;
        }
        
        /* Connect/Disconnect wallet buttons get green console light */
        .btn[onclick*="connectWallet"]::before,
        .btn[onclick*="disconnectWallet"]::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: var(--console-green);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 10px var(--console-green),
                0 0 20px var(--console-green),
                inset 0 0 5px rgba(255, 255, 255, 0.3);
            opacity: 0.7;
            transition: all 0.3s ease;
        }
        
        /* Primary action buttons get green console light */
        .btn.btn-primary::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: var(--console-green);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 10px var(--console-green),
                0 0 20px var(--console-green),
                inset 0 0 5px rgba(255, 255, 255, 0.3);
            opacity: 0.7;
            transition: all 0.3s ease;
        }
        
        /* Basic button hover (no light change) */
        .btn:hover {
            transform: translateY(1px);
            border-color: #4a5568;
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.6),
                inset 0 -2px 0 #1a1f2e,
                inset 0 2px 0 rgba(255, 255, 255, 0.15),
                0 0 0 2px #4a5568;
        }
        
        /* Connect/Disconnect wallet buttons hover with green light */
        .btn[onclick*="connectWallet"]:hover,
        .btn[onclick*="disconnectWallet"]:hover {
            border-color: var(--console-green);
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.6),
                inset 0 -2px 0 #1a1f2e,
                inset 0 2px 0 rgba(255, 255, 255, 0.15),
                0 0 0 2px var(--console-green),
                var(--console-glow);
        }
        
        .btn[onclick*="connectWallet"]:hover::before,
        .btn[onclick*="disconnectWallet"]:hover::before {
            background: var(--console-green);
            box-shadow: 
                0 0 15px var(--console-green),
                0 0 25px var(--console-green),
                0 0 35px var(--console-green),
                inset 0 0 8px rgba(255, 255, 255, 0.4);
            opacity: 1;
        }
        
        /* Primary buttons hover with green light */
        .btn.btn-primary:hover {
            border-color: var(--console-green);
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.6),
                inset 0 -2px 0 #1a1f2e,
                inset 0 2px 0 rgba(255, 255, 255, 0.15),
                0 0 0 2px var(--console-green),
                var(--console-glow);
        }
        
        .btn.btn-primary:hover::before {
            background: var(--console-green);
            box-shadow: 
                0 0 15px var(--console-green),
                0 0 25px var(--console-green),
                0 0 35px var(--console-green),
                inset 0 0 8px rgba(255, 255, 255, 0.4);
            opacity: 1;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            border-color: #4a5568;
            box-shadow: var(--button-shadow);
        }
        
        .btn:disabled::before {
            background: #666;
            opacity: 0.3;
            box-shadow: none;
        }
        
        .btn:active {
            transform: translateY(3px);
            box-shadow: 
                inset 0 2px 0 #1a1f2e,
                inset 0 -1px 0 rgba(255, 255, 255, 0.1),
                0 0 0 2px var(--console-green);
        }

        /* Secondary button (amber console light) */
        .btn-secondary {
            background: var(--console-metal);
            border: 3px solid #2d3748;
            color: var(--primary-text);
        }
        
        .btn-secondary::before {
            background: var(--console-amber);
            box-shadow: 
                0 0 10px var(--console-amber),
                0 0 20px var(--console-amber),
                inset 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            border-color: var(--console-amber);
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.6),
                inset 0 -2px 0 #1a1f2e,
                inset 0 2px 0 rgba(255, 255, 255, 0.15),
                0 0 0 2px var(--console-amber),
                0 0 20px rgba(255, 191, 0, 0.4);
        }
        
        .btn-secondary:hover::before {
            background: var(--console-amber);
            box-shadow: 
                0 0 15px var(--console-amber),
                0 0 25px var(--console-amber),
                0 0 35px var(--console-amber),
                inset 0 0 8px rgba(255, 255, 255, 0.4);
        }

        /* Warning button (red console light) */
        .btn-warning {
            background: var(--console-metal);
            border: 3px solid #2d3748;
            color: var(--primary-text);
        }
        
        .btn-warning::before {
            background: var(--console-red);
            box-shadow: 
                0 0 10px var(--console-red),
                0 0 20px var(--console-red),
                inset 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .btn-warning:hover {
            border-color: var(--console-red);
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.6),
                inset 0 -2px 0 #1a1f2e,
                inset 0 2px 0 rgba(255, 255, 255, 0.15),
                0 0 0 2px var(--console-red),
                0 0 20px rgba(255, 7, 58, 0.4);
        }
        
        .btn-warning:hover::before {
            background: var(--console-red);
            box-shadow: 
                0 0 15px var(--console-red),
                0 0 25px var(--console-red),
                0 0 35px var(--console-red),
                inset 0 0 8px rgba(255, 255, 255, 0.4);
        }

        /* Submarine Console Status Messages */
        .status-message {
            padding: var(--spacing-md);
            border-radius: 4px;
            margin: var(--spacing-md) 0;
            font-family: 'Roboto Mono', monospace;
            font-weight: 600;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            border: 2px solid;
        }
        
        .status-message::before {
            content: '';
            position: absolute;
            left: var(--spacing-sm);
            top: 50%;
            transform: translateY(-50%);
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .status-success {
            background: rgba(57, 255, 20, 0.1);
            border-color: var(--console-green);
            color: var(--console-green);
        }
        
        .status-success::before {
            background: var(--console-green);
            box-shadow: 0 0 8px var(--console-green);
        }

        .status-error {
            background: rgba(255, 7, 58, 0.1);
            border-color: var(--console-red);
            color: var(--console-red);
        }
        
        .status-error::before {
            background: var(--console-red);
            box-shadow: 0 0 8px var(--console-red);
        }

        .status-warning {
            background: rgba(255, 191, 0, 0.1);
            border-color: var(--console-amber);
            color: var(--console-amber);
        }
        
        .status-warning::before {
            background: var(--console-amber);
            box-shadow: 0 0 8px var(--console-amber);
        }

        .contracts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: var(--spacing-md);
            justify-items: center;
        }

        /* Submarine Console Main Card */
        .main-card {
            background: var(--metallic-bg);
            backdrop-filter: blur(15px);
            border: 2px solid #2d3748;
            border-radius: var(--border-radius);
            padding: var(--spacing-xl) var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            width: 100%;
            max-width: 800px;
            box-shadow: var(--metallic-shadow);
            position: relative;
            text-align: center;
        }
        
        .main-card::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            right: 3px;
            height: 2px;
            background: linear-gradient(90deg, var(--console-green) 0%, var(--console-amber) 50%, var(--console-red) 100%);
            border-radius: 2px;
            opacity: 0.6;
        }

        /* WW2 CRT Screen Styling */
        :root {
            /* WW2 CRT Monitor Colors - Blue Phosphor */
            --crt-blue: #00d4ff;
            --crt-blue-dim: #0099cc;
            --crt-blue-bright: #44ddff;
            --crt-background: #000011;
            --crt-dark: #000008;
            --crt-scanline: rgba(0, 212, 255, 0.03);
            --crt-glow: 0 0 5px #00d4ff, 0 0 10px #00d4ff, 0 0 15px #00d4ff;
            --crt-text-shadow: 0 0 5px currentColor;
        }

        /* Contract Card as CRT Screen */
        .contract-card {
            background: 
                linear-gradient(180deg, var(--crt-dark) 0%, var(--crt-background) 50%, var(--crt-dark) 100%),
                radial-gradient(ellipse at center, rgba(0, 212, 255, 0.1) 0%, transparent 70%);
            backdrop-filter: blur(15px);
            border: 3px solid #2d3748;
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            text-align: center;
            overflow: visible;
            box-shadow: 
                var(--metallic-shadow),
                inset 0 0 50px rgba(0, 212, 255, 0.1);
                
            /* CRT Monitor Effect */
            font-family: 'Roboto Mono', monospace;
        }
        
        /* CRT Scanlines Effect */
        .contract-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                var(--crt-scanline) 2px,
                var(--crt-scanline) 4px
            );
            pointer-events: none;
            border-radius: var(--border-radius);
            animation: scanlines 3s linear infinite;
        }
        
        @keyframes scanlines {
            0% { transform: translateY(0px); }
            100% { transform: translateY(4px); }
        }
        
        /* CRT Monitor Border with Corner Details */
        .contract-card::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: 
                linear-gradient(45deg, #2d3748 0%, #4a5568 50%, #2d3748 100%);
            border-radius: calc(var(--border-radius) + 3px);
            z-index: -1;
            border: 1px solid var(--crt-blue-dim);
        }
        
        .contract-card:hover {
            transform: translateY(-4px);
            border-color: var(--console-green);
            box-shadow: 
                var(--metallic-shadow),
                0 0 25px rgba(57, 255, 20, 0.2),
                0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .contract-card:hover::before {
            opacity: 1;
            box-shadow: 
                0 0 15px var(--console-green),
                0 0 25px var(--console-green),
                0 0 35px var(--console-green),
                inset 0 0 8px rgba(255, 255, 255, 0.4);
        }
        
        
        @keyframes cardBorder {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes buttonGlow {
            0% { 
                box-shadow: 
                    0 8px 24px rgba(102, 126, 234, 0.3),
                    0 0 0 1px rgba(255, 255, 255, 0.1),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
            100% { 
                box-shadow: 
                    0 12px 32px rgba(102, 126, 234, 0.4),
                    0 0 0 1px rgba(255, 255, 255, 0.15),
                    inset 0 1px 0 rgba(255, 255, 255, 0.25);
            }
        }
        
        /* Loading spinner enhancement */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 60px;
        }
        
        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: #667eea;
            border-right-color: #764ba2;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Input field enhancements */
        input, select, textarea {
            background: rgba(255, 255, 255, 0.08) !important;
            backdrop-filter: blur(10px) !important;
            border: 1px solid rgba(255, 255, 255, 0.15) !important;
            border-radius: 12px !important;
            padding: 12px 16px !important;
            color: white !important;
            font-size: 14px !important;
            transition: all 0.3s ease !important;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none !important;
            border-color: rgba(102, 126, 234, 0.5) !important;
            box-shadow: 
                0 0 0 3px rgba(102, 126, 234, 0.1),
                0 8px 24px rgba(102, 126, 234, 0.2) !important;
            background: rgba(255, 255, 255, 0.12) !important;
        }
        
        input::placeholder, select::placeholder, textarea::placeholder {
            color: rgba(255, 255, 255, 0.5) !important;
        }

        /* WW2 CRT Screen Text Styling */
        .contract-title {
            font-family: 'Roboto Mono', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: var(--spacing-md);
            color: var(--crt-blue-bright);
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: var(--crt-glow);
            animation: crtFlicker 4s ease-in-out infinite alternate;
        }
        
        @keyframes crtFlicker {
            0% { 
                opacity: 0.95;
                text-shadow: var(--crt-glow);
            }
            50% { 
                opacity: 1;
                text-shadow: 0 0 3px #00d4ff, 0 0 6px #00d4ff, 0 0 12px #00d4ff, 0 0 18px #00d4ff;
            }
            100% { 
                opacity: 0.98;
                text-shadow: var(--crt-glow);
            }
        }

        .contract-info {
            display: grid;
            gap: var(--spacing-xs);
            margin-bottom: var(--spacing-md);
            text-align: center;
            max-width: 100%;
            background: rgba(0, 0, 17, 0.3);
            border: 1px solid var(--crt-blue-dim);
            border-radius: 4px;
            padding: var(--spacing-md);
            box-shadow: inset 0 0 20px rgba(0, 212, 255, 0.1);
        }

        .info-row {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: var(--spacing-xs) 0;
            min-height: 24px;
            flex-direction: column;
            gap: var(--spacing-xs);
            border-bottom: 1px dotted rgba(0, 212, 255, 0.3);
            position: relative;
        }
        
        .info-row:last-child {
            border-bottom: none;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
    

        .info-label {
            color: var(--crt-blue-dim);
            font-family: 'Roboto Mono', monospace;
            font-weight: 500;
            font-size: 0.85rem;
            flex-shrink: 0;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 3px currentColor;
        }

        .info-value {
            color: var(--crt-blue-bright);
            font-family: 'Roboto Mono', monospace;
            background: rgba(0, 0, 17, 0.6);
            border: 1px solid rgba(0, 212, 255, 0.3);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: 2px;
            font-size: 0.8rem;
            text-align: center;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            word-break: break-all;
            font-weight: bold;
            text-shadow: 0 0 5px currentColor;
            box-shadow: inset 0 0 10px rgba(0, 212, 255, 0.2);
        }

        .contract-actions {
            display: flex;
            gap: var(--spacing-xs);
            flex-wrap: wrap;
            justify-content: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .stat-card {
            background: var(--accent-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-color);
            margin-bottom: var(--spacing-xs);
        }

        .stat-label {
            color: var(--secondary-text);
            font-size: 0.85rem;
        }

        /* WW2 CRT Copy Button */
        .copy-btn {
            background: rgba(0, 0, 17, 0.6);
            border: 1px solid var(--crt-blue-dim);
            color: var(--crt-blue);
            cursor: pointer;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.7rem;
            margin-left: var(--spacing-xs);
            padding: var(--spacing-xs);
            border-radius: 2px;
            transition: all 0.3s ease;
            min-width: 24px;
            height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 0 3px currentColor;
        }

        .copy-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            color: var(--crt-blue-bright);
            border-color: var(--crt-blue-bright);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
            text-shadow: 0 0 5px currentColor;
        }

        .token-info {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            flex-wrap: wrap;
            justify-content: center;
            max-width: 100%;
        }

        /* WW2 CRT Token Ticker */
        .token-ticker {
            background: var(--crt-blue);
            color: var(--crt-background);
            padding: 2px 6px;
            border-radius: 2px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.6rem;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-shadow: none;
            box-shadow: 0 0 5px rgba(0, 212, 255, 0.3);
            border: 1px solid var(--crt-blue-bright);
        }

        /* WW2 CRT Screen User Stats */
        .user-stats {
            background: 
                linear-gradient(180deg, var(--crt-dark) 0%, var(--crt-background) 50%, var(--crt-dark) 100%);
            border: 1px solid var(--crt-blue-dim);
            border-radius: 4px;
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            text-align: center;
            box-shadow: 
                inset 0 0 20px rgba(0, 212, 255, 0.1),
                0 0 10px rgba(0, 212, 255, 0.2);
            position: relative;
        }
        
        .user-stats::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 3px,
                rgba(0, 212, 255, 0.02) 3px,
                rgba(0, 212, 255, 0.02) 6px
            );
            pointer-events: none;
            border-radius: 4px;
        }

        .user-stats h4 {
            color: var(--crt-blue-bright);
            margin-bottom: var(--spacing-sm);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: var(--crt-glow);
        }
        
        .user-stats .info-row {
            border-bottom: 1px dotted rgba(0, 212, 255, 0.4);
        }

        /* WW2 CRT Admin Section */
        .admin-section {
            border: 2px solid var(--crt-blue-bright);
            border-top: 3px solid var(--console-red);
            margin-top: var(--spacing-lg);
            padding: var(--spacing-lg);
            text-align: center;
            background: linear-gradient(135deg, rgba(60, 0, 0, 0.4), rgba(40, 0, 0, 0.6));
            border-radius: 8px;
            box-shadow: 
                inset 0 0 20px rgba(0, 212, 255, 0.15),
                0 4px 15px rgba(0, 212, 255, 0.2),
                0 0 30px rgba(255, 7, 58, 0.1);
            position: relative;
            backdrop-filter: blur(2px);
        }

        .admin-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, 
                var(--console-red) 0%, 
                var(--crt-blue-bright) 50%, 
                var(--console-red) 100%);
            animation: pulse 2s ease-in-out infinite alternate;
        }

        .admin-title {
            color: var(--console-red);
            font-family: 'Roboto Mono', monospace;
            font-weight: 700;
            margin-bottom: var(--spacing-md);
            font-size: 1rem;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 
                0 0 10px var(--console-red),
                0 0 20px var(--console-red),
                0 0 30px rgba(255, 7, 58, 0.5);
            position: relative;
        }
        
        .admin-title::before {
            content: '[ ';
            color: var(--console-red);
            font-weight: bold;
        }

        .admin-title::after {
            content: ' ]';
            color: var(--console-red);
            font-weight: bold;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            backdrop-filter: blur(8px);
            overflow-y: auto;
            padding: 20px;
            animation: modalFadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes modalFadeIn {
            from { opacity: 0; backdrop-filter: blur(0px); }
            to { opacity: 1; backdrop-filter: blur(8px); }
        }

        .modal-content {
            position: relative;
            margin: 50px auto;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(25px);
            border-radius: 28px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 
                0 40px 80px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
            max-height: 90vh;
            animation: modalSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            text-align: center;
        }
    
        
        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #f5576c 75%, #4facfe 100%);
            background-size: 200% 100%;
            animation: cardBorder 3s ease-in-out infinite;
            border-radius: 28px 28px 0 0;
        }
        
        @keyframes modalSlideIn {
            from { 
                opacity: 0; 
                transform: translateY(-50px) scale(0.95); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
        }
        
        .modal-content {
            overflow-y: auto;
            min-height: fit-content;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 2rem;
            cursor: pointer;
            color: var(--secondary-text);
            transition: color 0.3s ease;
        }

        .close-btn:hover {
            color: var(--error-color);
        }

        .copy-btn {
            background: none;
            border: none;
            color: var(--accent-color);
            cursor: pointer;
            font-size: 0.8rem;
            margin-left: 5px;
            padding: 2px 5px;
            border-radius: 3px;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            background: var(--accent-color);
            color: var(--primary-bg);
        }

        /* Custom Admin Modals - Coinbase Wallet Compatible */
        .admin-modal {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0, 0, 0, 0.9) !important;
            z-index: 99999 !important;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .admin-modal-content {
            background: var(--metallic-bg);
            border: 2px solid var(--console-green);
            border-radius: var(--border-radius);
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 20px rgba(57, 255, 20, 0.3);
            position: relative;
            z-index: 100000;
        }

        .admin-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--console-green);
        }

        .admin-modal-header h3 {
            color: var(--console-green);
            font-family: 'Orbitron', monospace;
            font-size: 1.25rem;
            margin: 0;
            text-shadow: 0 0 10px var(--console-green);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .admin-close-btn {
            background: none;
            border: none;
            color: var(--console-green);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .admin-close-btn:hover {
            color: var(--warning-color);
            text-shadow: 0 0 10px var(--warning-color);
        }

        .admin-form-group {
            margin-bottom: 1.5rem;
        }

        .admin-form-group label {
            display: block;
            color: var(--console-green);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .admin-input {
            width: 100%;
            background: var(--console-metal);
            border: 2px solid #2d3748;
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            color: var(--primary-text);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .admin-input:focus {
            outline: none;
            border-color: var(--console-green);
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3);
        }

        .admin-input::placeholder {
            color: var(--secondary-text);
        }

        .admin-info-box {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--console-blue);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-bottom: 1.5rem;
            color: var(--primary-text);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            word-break: break-all; /* Break long addresses */
            overflow-wrap: break-word; /* Better word wrapping */
        }

        .admin-warning-box {
            background: rgba(255, 7, 58, 0.1);
            border: 1px solid var(--console-red);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-bottom: 1.5rem;
            color: var(--warning-text);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .admin-btn-group {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }

        .admin-btn {
            background: var(--console-metal);
            border: 2px solid #2d3748;
            color: var(--primary-text);
            padding: var(--spacing-sm) var(--spacing-lg);
            border-radius: var(--border-radius);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 100px;
        }

        .admin-btn.primary {
            border-color: var(--console-green);
            color: var(--console-green);
        }

        .admin-btn.primary:hover {
            background: rgba(57, 255, 20, 0.1);
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.3);
        }

        .admin-btn.secondary {
            border-color: var(--console-amber);
            color: var(--console-amber);
        }

        .admin-btn.secondary:hover {
            background: rgba(255, 191, 0, 0.1);
            box-shadow: 0 0 15px rgba(255, 191, 0, 0.3);
        }

        .admin-btn.danger {
            border-color: var(--console-red);
            color: var(--console-red);
        }

        .admin-btn.danger:hover {
            background: rgba(255, 7, 58, 0.1);
            box-shadow: 0 0 15px rgba(255, 7, 58, 0.3);
        }

        .admin-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .admin-section {
            border: 2px solid var(--crt-blue-bright);
            border-top: 3px solid var(--console-red);
            margin-top: 20px;
            padding: 20px 15px;
            background: linear-gradient(135deg, rgba(60, 0, 0, 0.4), rgba(40, 0, 0, 0.6));
            border-radius: 8px;
            box-shadow: 
                inset 0 0 15px rgba(0, 212, 255, 0.15),
                0 2px 10px rgba(0, 212, 255, 0.2);
            position: relative;
        }

        .admin-title {
            color: var(--console-red);
            font-weight: 700;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 0.9rem;
            text-shadow: 0 0 10px var(--console-red);
        }

        .token-info {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-wrap: wrap;
        }

        .token-ticker {
            background: var(--accent-color);
            color: var(--primary-bg);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .user-stats {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .user-stats h4 {
            color: var(--success-color);
            margin-bottom: 10px;
        }

        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--secondary-bg);
            color: var(--primary-text);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid var(--border-color);
        }
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }

            .contracts-grid {
                grid-template-columns: 1fr;
            }

            .wallet-section {
                flex-direction: column;
            }

            .container {
                padding: var(--spacing-sm);
                text-align: center;
            }

            .header {
                padding: var(--spacing-lg) var(--spacing-md);
                text-align: center;
            }

            .header h1 {
                font-size: 1.8rem;
                text-align: center;
            }

            .header p {
                font-size: 0.9rem;
                text-align: center;
            }

            .form-grid {
                grid-template-columns: 1fr;
                text-align: center;
            }

            .form-group {
                text-align: center;
            }

            .form-group label {
                text-align: center;
                margin-bottom: var(--spacing-sm);
            }

            .contracts-grid {
                grid-template-columns: 1fr;
                justify-items: center;
                padding: 15px 0;
                width: calc(100vw - 20px);
                margin: 0 auto;
                left: 0;
                right: 0;
                position: relative;
            }

            .contract-card {
                padding: var(--spacing-md);
                max-width: calc(100vw - 50px);
                width: 100%;
                margin: 0 auto;
                text-align: center;
                box-sizing: border-box;
            }

            .wallet-section {
                flex-direction: column;
                gap: var(--spacing-sm);
            }

            .wallet-btn {
                width: 100%;
                max-width: 300px;
            }

            .wallet-info {
                width: 100%;
                max-width: 300px;
                text-align: center;
            }

            .info-row {
                flex-direction: column;
                align-items: flex-start;
                gap: var(--spacing-xs);
            }

            .info-label {
                font-size: 0.8rem;
            }

            .info-value {
                max-width: 100%;
                text-align: left;
            }

            .token-info {
                justify-content: flex-start;
                max-width: 100%;
            }

            .contract-actions {
                justify-content: center;
            }

            .btn {
                font-size: 0.8rem;
                padding: var(--spacing-xs) var(--spacing-md);
                min-height: 32px;
            }

            .modal-content {
                padding: var(--spacing-md);
                max-width: 95%;
            }

            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            }

            .stat-value {
                font-size: 1.2rem;
            }


        /* Search and Filter Styling */
        .search-filter-container {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .search-box {
            position: relative;
            margin-bottom: var(--spacing-md);
        }

        .search-input {
            width: 100%;
            padding: 12px 50px 12px 16px;
            border: 2px solid var(--border-color);
            border-radius: 25px;
            background: var(--bg-color);
            color: var(--text-color);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .search-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--accent-color);
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .search-btn:hover {
            background: var(--accent-color-hover);
            transform: translateY(-50%) scale(1.1);
        }

        .filter-controls {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
            align-items: center;
        }

        .filter-select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--bg-color);
            color: var(--text-color);
            font-size: 0.9rem;
            min-width: 140px;
            transition: all 0.3s ease;
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .clear-filters-btn, .refresh-btn {
            padding: 8px 16px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: var(--secondary-bg);
            color: var(--text-color);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .clear-filters-btn:hover, .refresh-btn:hover {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .refresh-btn {
            padding: 8px;
            min-width: auto;
        }

        .results-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--secondary-text);
            font-size: 0.9rem;
        }

        /* Enhanced Visual Elements */
        .apy-highlight {
            background: linear-gradient(135deg, var(--success-color), #10b981);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.9rem;
            display: inline-block;
        }

        .token-ticker {
            background: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .status-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-active {
            background: rgba(34, 197, 94, 0.2);
            color: var(--success-color);
            border: 1px solid var(--success-color);
        }

        .status-new {
            background: rgba(59, 130, 246, 0.2);
            color: var(--accent-color);
            border: 1px solid var(--accent-color);
        }
    </style>
</head>
<body class="page-staking"> <!-- Determines hero picture -->
    <!-- Top chrome: fixed wrapper that always stays above the page -->
    <div class="site-chrome">
        <!-- Transaction Ticker Widget -->
        <iframe id="transaction-ticker-iframe" src="../transaction-ticker-widget.html" scrolling="no"
            title="Transaction Ticker">
        </iframe>

        <!-- ========== Nav Bar =============
        ====================================
        =================================-->

        <nav class="navbar">

            <!-- Left: Logo -->
            <div class="navlogo">WILD WEST</div>

            <!-- Center: Main Links -->
            <ul class="nav-links">
                <li><a href="../index.html">Home</a></li>

                <li class="dropdown">
                    <button class="dropdown-toggle" type="button" aria-haspopup="menu" aria-expanded="false">
                        Launch Token â–¾
                    </button>
                    <ul class="dropdown-menu" role="menu">
                        <!-- NOTE: from /pages/ use same-folder path, not ./pages/... -->
                        <li><a href="launch-base.html" role="menuitem" aria-current="page">Base</a></li>
                        <li><a href="coming-soon.html" role="menuitem">Solana (Coming soon!)</a></li>
                    </ul>
                </li>

                <li><a href="coming-soon.html">NFT Marketplace</a></li>

                <li class="dropdown">
                    <button class="dropdown-toggle" type="button" aria-haspopup="menu" aria-expanded="false">
                        Staking â–¾
                    </button>
                    <ul class="dropdown-menu" role="menu">
                        <li><a href="coming-soon.html" role="menuitem">Base</a></li>
                        <li><a href="coming-soon.html" role="menuitem">Solana (Coming soon!)</a></li>
                    </ul>
                </li>

                <li class="dropdown">
                    <button class="dropdown-toggle" type="button" aria-haspopup="menu" aria-expanded="false">
                        Token Locking â–¾
                    </button>
                    <ul class="dropdown-menu" role="menu">
                        <li><a href="locking-base.html" role="menuitem">Base</a></li>
                        <li><a href="locking-solana.html" role="menuitem">Solana</a></li>
                    </ul>
                </li>

                <li><a href="furnace.html">Token Furnace</a></li>
                <li><a href="the-team.html">The Team</a></li>
                <li><a href="coming-soon.html">Arcade</a></li> <!-- (double-check: both go to team.html) -->
            </ul>

            <!-- Right: Icons -->
            <div class="nav-actions">
                <a href="https://t.me/wildwestlaunchpad" target="_blank" rel="noopener">
                    <img src="../images/icons/icons8-telegram-app-240_WHITE.png" alt="Telegram" class="nav-icon">
                </a>
                <a href="https://x.com/WILDWESTLP?t=wmcDfvCKnkAaLCtJbmAxgA" target="_blank" rel="noopener">
                    <img src="../images/icons/icons8-twitterx-240_WHITE.png" alt="Twitter/X" class="nav-icon">
                </a>
                <a href="https://dexscreener.com/base/0x8129609e5303910464fce3022a809fa44455fe9a" target="_blank"
                    rel="noopener">
                    <img src="../images/icons/661375b92a7e161501f4b5e5_dexscreener.322a5a2d_WHITE.png" alt="DEXScreener"
                        class="nav-icon">
                </a>
                <div class="connect-wallet-btn">
                    <a>Connect Wallet</a>
                </div>
            </div>
        </nav>

        <!-- Token Furnace Style Wallet Modal System -->
        <script>
            // Utility function for mobile detection
            function isMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
            }

            // Get mobile-aware wallet message
            function getMobileAwareWalletMessage() {
                if (isMobileDevice()) {
                    return 'Please open this website in your EVM wallet browser (MetaMask, Trust Wallet, Coinbase Wallet, etc.)';
                } else {
                    return 'Please install MetaMask or another compatible EVM wallet to use this application';
                }
            }

            // Token Furnace Style Wallet Modal Implementation for Base Launch
            document.addEventListener('DOMContentLoaded', function () {
                console.log('ðŸš€ Base Launch: Setting up token furnace style wallet');
                setupBaseLaunchWallet();
            });

            function showChainSelectionModal() {
                console.log('ðŸš€ Base Launch: showChainSelectionModal called!');

                // Focus on Ethereum/Base wallets only for base launch page
                const availableWallets = {
                    ethereum: []
                };

                // Detect Ethereum/Base wallets
                if (window.ethereum) {
                    const providers = window.ethereum.providers || [window.ethereum];

                    providers.forEach(provider => {
                        if (provider.isMetaMask) {
                            availableWallets.ethereum.push({ name: 'MetaMask', provider: provider });
                        }
                        if (provider.isCoinbaseWallet) {
                            availableWallets.ethereum.push({ name: 'Coinbase Wallet', provider: provider });
                        }
                        if (provider.isRabby) {
                            availableWallets.ethereum.push({ name: 'Rabby Wallet', provider: provider });
                        }
                        if (provider.isTrust) {
                            availableWallets.ethereum.push({ name: 'Trust Wallet', provider: provider });
                        }
                    });

                    if (availableWallets.ethereum.length === 0) {
                        availableWallets.ethereum.push({ name: 'Ethereum Wallet', provider: window.ethereum });
                    }
                }

                console.log('ðŸ” Base Launch: Detected wallets:', availableWallets);

                const modal = document.createElement('div');
                modal.id = 'walletConnectionModal'; // Add ID for easier reference
                modal.className = 'wallet-modal';
                modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center;
                z-index: 10000; animation: fadeIn 0.2s ease-out;
            `;

                let walletOptionsHTML = '';

                if (availableWallets.ethereum.length > 0) {
                    walletOptionsHTML += '<h4 style="color: #00eaff; margin: 1rem 0 0.5rem 0; font-size: 1rem; text-align: center;">Base Network (Ethereum)</h4>';
                    availableWallets.ethereum.forEach((wallet, index) => {
                        walletOptionsHTML += `
                        <button onclick="connectSpecificWallet('ethereum', ${index})" style="
                            display: block; width: 100%; margin: 8px 0; padding: 12px 16px;
                            background: linear-gradient(135deg, #0052ff, #0041cc);
                            color: white; border: 1px solid rgba(0, 234, 255, 0.3); border-radius: 8px;
                            cursor: pointer; font-family: 'Segoe UI', sans-serif; font-size: 0.9rem;
                            transition: all 0.3s ease; text-align: center;
                        " onmouseover="this.style.background='linear-gradient(135deg, #0066ff, #0052ff)'; this.style.borderColor='#00eaff'; this.style.transform='translateY(-1px)'" onmouseout="this.style.background='linear-gradient(135deg, #0052ff, #0041cc)'; this.style.borderColor='rgba(0, 234, 255, 0.3)'; this.style.transform='translateY(0)'">
                            Connect ${wallet.name}
                        </button>
                    `;
                    });
                } else {
                    // Mobile-aware messaging when no wallets detected
                    if (isMobileDevice()) {
                        walletOptionsHTML = `
                        <div style="text-align: center; padding: 2rem; color: #ff6b6b;">
                            <h4 style="color: #ff6b6b; margin-bottom: 1rem; text-align: center;">Open in Wallet Browser</h4>
                            <p style="margin-bottom: 1.5rem; color: #c0c0c0; text-align: center; line-height: 1.5;">To use this application on mobile, please open this website in your EVM wallet's built-in browser:</p>
                            <div style="text-align: center; margin-bottom: 1.5rem;">
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">ðŸ“± MetaMask Mobile</span> â†’ Browser Tab â†’ Visit this URL</p>
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">ðŸ“± Trust Wallet</span> â†’ Browser Tab â†’ Visit this URL</p>
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">ðŸ“± Coinbase Wallet</span> â†’ Browser Tab â†’ Visit this URL</p>
                                <p style="margin: 0.8rem 0; color: #c0c0c0; font-size: 0.9rem;"><span style="color: #00eaff; font-weight: 600;">ðŸ“± Other EVM Wallets</span> â†’ In-App Browser</p>
                            </div>
                            <div style="background: rgba(0, 234, 255, 0.1); border: 1px solid rgba(0, 234, 255, 0.3); border-radius: 8px; padding: 1rem; margin-top: 1rem;">
                                <p style="margin: 0; color: #00eaff; font-size: 0.85rem; font-weight: 500;">ðŸ’¡ Tip: Copy this URL and paste it in your mobile wallet's browser</p>
                            </div>
                        </div>
                    `;
                    } else {
                        walletOptionsHTML = `
                        <div style="text-align: center; padding: 2rem; color: #ff6b6b;">
                            <h4 style="color: #ff6b6b; margin-bottom: 1rem; text-align: center;">No Base Wallets Detected</h4>
                            <p style="margin-bottom: 1rem; color: #c0c0c0; text-align: center;">Please install a Base-compatible wallet:</p>
                            <div style="text-align: center;">
                                <p style="margin: 0.5rem 0; color: #c0c0c0; text-align: center;"><a href="https://metamask.io" target="_blank" style="color: #00eaff;">MetaMask</a> (Base Network)</p>
                                <p style="margin: 0.5rem 0; color: #c0c0c0; text-align: center;"><a href="https://wallet.coinbase.com" target="_blank" style="color: #00eaff;">Coinbase Wallet</a> (Base Network)</p>
                                <p style="margin: 0.5rem 0; color: #c0c0c0; text-align: center;"><a href="https://rabby.io" target="_blank" style="color: #00eaff;">Rabby Wallet</a> (Base Network)</p>
                                <p style="margin: 0.5rem 0; color: #c0c0c0; text-align: center;"><a href="https://trustwallet.com" target="_blank" style="color: #00eaff;">Trust Wallet</a> (Base Network)</p>
                            </div>
                        </div>
                    `;
                    }
                }

                modal.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, #1a1a2e, #16213e);
                    border: 2px solid #00eaff;
                    border-radius: 16px;
                    box-shadow: 0 0 30px rgba(0, 234, 255, 0.3);
                    max-width: 400px;
                    width: 90vw;
                    max-height: 80vh;
                    overflow-y: auto;
                    font-family: 'Segoe UI', sans-serif;
                ">
                    <div style="
                        padding: 1.5rem;
                        border-bottom: 1px solid rgba(0, 234, 255, 0.2);
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    ">
                        <h3 style="margin: 0; color: #00eaff; font-size: 1.25rem; text-align: center;">Connect Base Wallet</h3>
                        <button class="close-modal-btn" style="
                            background: none; border: none; color: #00eaff; font-size: 1.5rem;
                            cursor: pointer; padding: 0; width: 30px; height: 30px;
                            display: flex; align-items: center; justify-content: center;
                            border-radius: 50%; transition: background-color 0.2s;
                        ">Ã—</button>
                    </div>
                    <div style="padding: 1.5rem;">
                        ${walletOptionsHTML}
                        <button class="cancel-modal-btn" style="
                            display: block; width: 100%; margin-top: 1rem; padding: 10px;
                            background: rgba(102, 102, 102, 0.8); color: white;
                            border: 1px solid rgba(0, 234, 255, 0.2); border-radius: 8px;
                            cursor: pointer; font-family: 'Segoe UI', sans-serif;
                        ">Cancel</button>
                    </div>
                </div>
            `;

                document.body.appendChild(modal);

                const closeBtn = modal.querySelector('.close-modal-btn');
                const cancelBtn = modal.querySelector('.cancel-modal-btn');

                function closeModal() {
                    modal.remove();
                }

                closeBtn.addEventListener('click', closeModal);
                cancelBtn.addEventListener('click', closeModal);
                modal.addEventListener('click', function (e) {
                    if (e.target === modal) closeModal();
                });

                // Store modal reference globally for easy closing
                window.currentWalletModal = modal;
                window.availableWallets = availableWallets;
            }

            window.connectSpecificWallet = async function (network, walletIndex) {
                console.log(`ðŸ”— Base Launch: Connecting to wallet ${walletIndex} on ${network} network`);

                try {
                    if (network === 'ethereum') {
                        const wallet = window.availableWallets.ethereum[walletIndex];
                        if (!wallet) {
                            throw new Error(`Wallet not found at index ${walletIndex}`);
                        }

                        console.log(`ðŸ“‹ Base Launch: Connecting to ${wallet.name}`);

                        const accounts = await wallet.provider.request({ method: 'eth_requestAccounts' });
                        if (accounts.length > 0) {
                            try {
                                await wallet.provider.request({
                                    method: 'wallet_switchEthereumChain',
                                    params: [{ chainId: '0x2105' }], // Base mainnet
                                });
                            } catch (switchError) {
                                if (switchError.code === 4902) {
                                    await wallet.provider.request({
                                        method: 'wallet_addEthereumChain',
                                        params: [{
                                            chainId: '0x2105',
                                            chainName: 'Base',
                                            nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                                            rpcUrls: [BASE_RPC_URL],
                                            blockExplorerUrls: ['https://basescan.org']
                                        }]
                                    });
                                }
                            }

                            // Update global state for launch page
                            window.currentAddress = accounts[0];
                            window.currentChain = 'base';
                            window.currentProvider = wallet.provider;

                            // CRITICAL: Set the main script variables immediately
                            provider = new ethers.providers.Web3Provider(wallet.provider);
                            signer = provider.getSigner();
                            userAddress = accounts[0];

                            // Initialize CONTRACT
                            CONTRACT = new ethers.Contract(TOKEN_FACTORY_ADDRESS, TOKEN_FACTORY_ABI, signer);

                            console.log('ðŸ”§ Base Launch: FIXED - Set provider:', !!provider);
                            console.log('ðŸ”§ Base Launch: FIXED - Set userAddress:', userAddress);

                            // Close modal IMMEDIATELY after successful connection
                            if (window.currentWalletModal) {
                                console.log('ðŸ”„ Base Launch: Closing wallet modal immediately');
                                window.currentWalletModal.remove();
                                window.currentWalletModal = null;
                            }

                            // Fallback: close modal by ID if reference didn't work
                            const modalById = document.getElementById('walletConnectionModal');
                            if (modalById) {
                                console.log('ðŸ”„ Base Launch: Closing modal by ID (fallback)');
                                modalById.remove();
                            }

                            // Fallback: close any remaining wallet modal by class
                            const modalByClass = document.querySelector('.wallet-modal');
                            if (modalByClass) {
                                console.log('ðŸ”„ Base Launch: Closing modal by class (fallback)');
                                modalByClass.remove();
                            }

                            // Update UI
                            updateBaseLaunchUI(accounts[0]);

                            console.log(`âœ… Base Launch: ${wallet.name} connected successfully!`);

                            // Load dashboards directly instead of page reload
                            setTimeout(async () => {
                                console.log('ðŸ”„ Base Launch: Loading user tokens...');
                                try {
                                    await connectWallet();
                                    await refreshDashboards();
                                } catch (e) {
                                    console.error('Dashboard loading failed:', e);
                                }
                            }, 500);

                            console.log(`âœ… Base Launch: ${wallet.name} connected successfully!`);
                        }
                    }
                } catch (error) {
                    const walletName = window.availableWallets.ethereum[walletIndex]?.name;
                    console.error(`âŒ Base Launch: ${walletName} connection failed:`, error);
                    alert(`Connection failed: ${error.message}`);
                }
            };

            function updateBaseLaunchUI(address) {
                const connectBtn = document.getElementById('connectBtn');

                if (connectBtn) {
                    const shortAddr = `${address.slice(0, 6)}...${address.slice(-4)}`;
                    connectBtn.textContent = `Connected: ${shortAddr}`;
                    connectBtn.style.background = 'linear-gradient(135deg, #0070f3, #00c851, #0051cc)';
                    connectBtn.style.backgroundSize = '200% 200%';
                    connectBtn.style.animation = 'gradientShift 6s ease infinite';
                    connectBtn.disabled = false; // Keep button clickable for disconnect option
                    connectBtn.style.cursor = 'pointer'; // Show it's still clickable
                }

                // Hide the connection prompt when wallet is connected
                const connectionStatus = document.getElementById('connectionStatus');
                if (connectionStatus) {
                    connectionStatus.style.display = 'none';
                }

                // Show main content after wallet connection
                const mainContent = document.getElementById('mainContent');
                const priceStatus = document.getElementById('priceStatus');
                const tokenManagement = document.getElementById('tokenManagementSection');
                if (mainContent) mainContent.style.display = 'block';
                if (priceStatus) priceStatus.style.display = 'block';
                if (tokenManagement) tokenManagement.style.display = 'block';

                // Enable functionality
                document.querySelectorAll('.form-input, .btn').forEach(el => {
                    if (el.id !== 'connectBtn') {
                        el.disabled = false;
                    }
                });

                // Update displays
                if (typeof updateDisplays === 'function') {
                    updateDisplays();
                }

                console.log('âœ… Base Launch: UI updated and functionality enabled');
            }

            function setupBaseLaunchWallet() {
                console.log('ðŸ”§ Base Launch: Setting up wallet connection');

                const connectBtn = document.getElementById('connectBtn');
                if (!connectBtn) {
                    console.error('âŒ Base Launch: Connect wallet button not found');
                    return;
                }

                connectBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('ðŸ”— Base Launch: Connect button clicked');
                    handleConnectButtonClick();
                });

                // Ensure button is properly centered on page load
                adjustButtonGroupLayout();

                console.log('âœ… Base Launch: Wallet setup complete');
            }

            // Smart connect button handler - connects or disconnects based on current state
            function handleConnectButtonClick() {
                // Check if wallet is already connected
                if (userAddress && provider) {
                    // Wallet is connected, ask if user wants to disconnect
                    const shortAddr = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                    const confirmDisconnect = confirm(`Disconnect wallet ${shortAddr}?\n\nThis will hide all token management features and return you to the connection screen.`);

                    if (confirmDisconnect) {
                        console.log('ðŸ”Œ User requested wallet disconnection');
                        handleWalletDisconnect();
                    }
                } else {
                    // Wallet is not connected, show connection modal
                    console.log('ðŸ”— User wants to connect wallet');
                    showChainSelectionModal();
                }
            }

            // Global variables
            window.currentAddress = null;
            window.currentChain = null;
            window.currentProvider = null;

            // NEW ANTI-SNIPER & ENHANCED FUNCTIONS

            // Helper function to load user tokens using createdTokens mapping
            async function getUserTokens(userAddress) {
                const tokens = [];
                let tokenIndex = 0;
                let maxAttempts = 100; // Prevent infinite loops

                try {
                    while (tokenIndex < maxAttempts) {
                        try {
                            const tokenInfo = await CONTRACT.createdTokens(userAddress, tokenIndex);
                            // Check if we got a valid token (tokenAddress != 0x0)
                            if (tokenInfo[0] && tokenInfo[0] !== '0x0000000000000000000000000000000000000000') {
                                tokens.push(tokenInfo);
                                tokenIndex++;
                            } else {
                                break; // No more tokens
                            }
                        } catch (e) {
                            break; // No more tokens or error occurred
                        }
                    }
                } catch (err) {
                    console.log('Error loading user tokens:', err.message);
                }

                return tokens;
            }

            // Batch swap accumulated token fees
            async function batchSwapTokens() {
                console.log('ðŸš€ batchSwapTokens() function called!');
                console.log('CONTRACT:', CONTRACT);
                console.log('User Address:', userAddress);

                if (!CONTRACT || !userAddress) {
                    console.log('âŒ Missing CONTRACT or userAddress');
                    showStatus('Please connect your wallet to continue', 'error');
                    return;
                }

                try {
                    console.log('ðŸ”„ Starting token fee swap...');

                    // First get user's tokens to check if they have any
                    const userTokens = await getUserTokens(userAddress);
                    console.log('ðŸ“‹ User tokens found:', userTokens.length);

                    if (userTokens.length === 0) {
                        showStatus('No tokens found. Please create a token first.', 'error');
                        return;
                    }

                    // Check different types of balances that might be stuck
                    console.log('ðŸ” Checking for different types of stuck tokens...');

                    // Check creator token balance (fees earned as tokens)
                    const tokenBalance = await CONTRACT.getCreatorTokenBalance(userAddress);
                    console.log('ðŸ’° Creator token balance:', ethers.utils.formatEther(tokenBalance), 'tokens');

                    // Check if there are any LP token fees accumulated
                    let hasStuckTokens = false;
                    const tokenAddress = userTokens[0][0]; // First token address
                    console.log('ðŸŽ¯ Checking token:', tokenAddress);

                    // Try to check if CONTRACT has any of the user's tokens
                    const ERC20_ABI = [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function decimals() view returns (uint8)",
                        "function symbol() view returns (string)"
                    ];

                    const tokenCONTRACT = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                    const CONTRACTTokenBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                    const tokenSymbol = await tokenCONTRACT.symbol();

                    console.log('ðŸ¦ CONTRACT balance of', tokenSymbol + ':', ethers.utils.formatEther(CONTRACTTokenBalance));

                    if (tokenBalance.gt(0)) {
                        console.log('âœ… Found creator token fees to swap');
                        hasStuckTokens = true;
                    } else if (CONTRACTTokenBalance.gt(0)) {
                        console.log('âœ… Found CONTRACT token balance that might need swapping');
                        hasStuckTokens = true;
                    } else {
                        showStatus('No stuck tokens found to swap. Token balance: ' + ethers.utils.formatEther(tokenBalance) + ', CONTRACT balance: ' + ethers.utils.formatEther(CONTRACTTokenBalance), 'info');
                        return;
                    }

                    // Proceed with swap
                    console.log('ðŸ”„ Attempting to swap tokens for:', tokenAddress);
                    console.log('ðŸ“Š Creator token balance to swap:', ethers.utils.formatEther(tokenBalance));
                    console.log('ðŸ¦ CONTRACT token balance found:', ethers.utils.formatEther(CONTRACTTokenBalance));

                    // The tokens are stuck in the CONTRACT but not assigned to creator yet
                    // Try rescueAndSellStuckTokens function instead
                    console.log('ðŸ’¡ Using rescueAndSellStuckTokens to rescue stuck tokens...');
                    showStatus('Collecting rewards from your tokens...', 'info');

                    try {
                        console.log('ï¿½ Calling rescueAndSellStuckTokens for token:', tokenAddress);
                        const rescueTx = await CONTRACT.rescueAndSellStuckTokens([tokenAddress]);
                        console.log('â³ Rescue transaction sent:', rescueTx.hash);

                        const rescueReceipt = await rescueTx.wait();
                        console.log('âœ… Rescue confirmed:', rescueReceipt.transactionHash);

                        if (rescueReceipt.logs && rescueReceipt.logs.length > 0) {
                            console.log('ï¿½ Rescue completed with', rescueReceipt.logs.length, 'events');
                        }

                        showStatus('Rewards successfully collected and converted to ETH!', 'success');

                        // Refresh displays to show updated ETH balances
                        await checkPlatformFees();
                        return;

                    } catch (rescueError) {
                        console.error('Rescue tokens error:', rescueError);
                        let errorMsg = 'Rescue failed: ' + rescueError.message;

                        if (rescueError.message.includes('execution reverted')) {
                            errorMsg = 'Rescue failed - may be insufficient tokens or no liquidity';
                        } else if (rescueError.message.includes('user rejected')) {
                            errorMsg = 'Transaction rejected by user';
                        } else if (rescueError.message.includes('insufficient funds')) {
                            errorMsg = 'Insufficient ETH for gas fees';
                        }

                        showStatus('âŒ ' + errorMsg, 'error');
                        return;
                    }

                    showStatus('Testing batch swap function directly...', 'info');

                    // First test with callStatic to see what the error is
                    try {
                        console.log('ðŸ§ª Testing batchSwapTokenFees with callStatic...');
                        const result = await CONTRACT.callStatic.batchSwapTokenFees(userAddress, tokenAddress);
                        console.log('âœ… callStatic succeeded, result:', result);
                    } catch (testError) {
                        console.log('âŒ callStatic failed:', testError.message);
                        if (testError.message.includes('INSUFFICIENT_BALANCE')) {
                            showStatus('Insufficient tokens available for processing', 'error');
                            return;
                        } else if (testError.message.includes('NO_LIQUIDITY')) {
                            showStatus('Trading liquidity not yet available for this token', 'error');
                            return;
                        } else if (testError.message.includes('NOT_AUTHORIZED')) {
                            showStatus('Unable to process tokens at this time', 'error');
                            return;
                        }
                        // Continue anyway to see the real error
                        console.log('ðŸ¤” Continuing with actual transaction despite callStatic error...');
                    }

                    showStatus('Processing token fees...', 'info');

                    // Call the batch swap function
                    const tx = await CONTRACT.batchSwapTokenFees(userAddress, tokenAddress);
                    console.log('â³ Swap transaction sent:', tx.hash);

                    const receipt = await tx.wait();
                    console.log('âœ… Swap confirmed:', receipt.transactionHash);

                    // Check how much was swapped
                    if (receipt.logs && receipt.logs.length > 0) {
                        console.log('ðŸ“‹ Swap completed with', receipt.logs.length, 'events');
                    }

                    showStatus('Token fees successfully processed!', 'success');

                    // Refresh displays to show updated ETH balances
                    await checkPlatformFees();

                } catch (error) {
                    console.error('Batch swap error:', error);
                    let errorMsg = 'Batch swap failed: ' + error.message;

                    if (error.message.includes('execution reverted')) {
                        errorMsg = 'Swap failed - may be insufficient liquidity or slippage too high';
                    } else if (error.message.includes('user rejected')) {
                        errorMsg = 'Transaction rejected by user';
                    } else if (error.message.includes('insufficient funds')) {
                        errorMsg = 'Insufficient ETH for gas fees';
                    }

                    showStatus('âŒ ' + errorMsg, 'error');
                }
            }

            // Show token selection dialog for multi-project fee collection
            async function showTokenSelectionDialog(tokenOptions) {
                return new Promise((resolve) => {
                    // Create modal dialog
                    const modal = document.createElement('div');
                    modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    font-family: Arial, sans-serif;
                `;

                    const dialog = document.createElement('div');
                    dialog.className = 'token-selection-modal';
                    dialog.style.cssText = `
                    background: white;
                    border-radius: 10px;
                    padding: 30px;
                    max-width: 600px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                `;

                    const tokensWithRewards = tokenOptions.filter(opt => opt.hasRewards);
                    const tokensWithoutRewards = tokenOptions.filter(opt => !opt.hasRewards);

                    dialog.innerHTML = `
                    <h2 style="margin-top: 0; color: #333; text-align: center;">Select Tokens to Collect Rewards</h2>
                    <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 12px; margin-bottom: 20px; color: #856404;">
                        <strong>Multiple Transaction Notice:</strong> Each selected token will require a separate transaction. You'll need to approve each transaction in your wallet.
                    </div>
                    <p style="color: #666; text-align: center; margin-bottom: 25px;">
                        Choose which tokens you want to collect LP rewards from to save on gas fees.
                    </p>
                    
                    ${tokensWithRewards.length > 0 ? `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #28a745; margin-bottom: 15px;">Tokens with Available Rewards:</h3>
                            ${tokensWithRewards.map(opt => `
                                <label style="display: block; margin-bottom: 10px; padding: 15px; border: 2px solid #28a745; border-radius: 8px; cursor: pointer; background-color: #f8fff8;">
                                    <input type="checkbox" value="${opt.index}" checked style="margin-right: 10px; transform: scale(1.3);">
                                    <div style="color: #333;">
                                        <strong style="font-size: 16px; color: #1a5f1a;">${opt.symbol}</strong>
                                        <br>
                                        <span style="color: #555; font-size: 14px;">Available: ${opt.rewardDisplay}</span>
                                        <br>
                                        <span style="color: #777; font-size: 12px;">Position ID: ${opt.tokenId}</span>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${tokensWithoutRewards.length > 0 ? `
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #dc3545; margin-bottom: 15px;">Tokens without Rewards:</h3>
                            ${tokensWithoutRewards.map(opt => `
                                <label style="display: block; margin-bottom: 10px; padding: 15px; border: 2px solid #ddd; border-radius: 8px; background-color: #f8f8f8;">
                                    <input type="checkbox" value="${opt.index}" disabled style="margin-right: 10px; transform: scale(1.3);">
                                    <div style="color: #666;">
                                        <strong style="font-size: 16px; color: #999;">${opt.symbol}</strong>
                                        <br>
                                        <span style="color: #999; font-size: 14px;">No rewards available</span>
                                        <br>
                                        <span style="color: #bbb; font-size: 12px;">Position ID: ${opt.tokenId || 'unknown'}</span>
                                    </div>
                                </label>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 30px; flex-wrap: wrap;">
                        <button id="selectAll" style="padding: 12px 24px; background-color: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Select All Available
                        </button>
                        <button id="confirmSelection" style="padding: 12px 24px; background-color: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Collect Selected (${tokensWithRewards.length} txns)
                        </button>
                        <button id="cancelSelection" style="padding: 12px 24px; background-color: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                            Cancel
                        </button>
                    </div>
                `;

                    modal.appendChild(dialog);
                    document.body.appendChild(modal);

                    // Event listeners
                    const selectAllBtn = dialog.querySelector('#selectAll');
                    const confirmBtn = dialog.querySelector('#confirmSelection');
                    const cancelBtn = dialog.querySelector('#cancelSelection');
                    const checkboxes = dialog.querySelectorAll('input[type="checkbox"]:not([disabled])');

                    // Function to update button text based on selection
                    const updateConfirmButtonText = () => {
                        const selectedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
                        confirmBtn.textContent = `Collect Selected (${selectedCount} txns)`;
                        confirmBtn.disabled = selectedCount === 0;
                        confirmBtn.style.opacity = selectedCount === 0 ? '0.5' : '1';
                    };

                    // Add change listeners to checkboxes
                    checkboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', updateConfirmButtonText);
                    });

                    selectAllBtn.addEventListener('click', () => {
                        checkboxes.forEach(cb => cb.checked = true);
                        updateConfirmButtonText();
                    });

                    confirmBtn.addEventListener('click', () => {
                        const selected = Array.from(checkboxes)
                            .filter(cb => cb.checked)
                            .map(cb => parseInt(cb.value));

                        document.body.removeChild(modal);
                        resolve(selected);
                    });

                    cancelBtn.addEventListener('click', () => {
                        document.body.removeChild(modal);
                        resolve(null);
                    });

                    // Close on backdrop click
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            document.body.removeChild(modal);
                            resolve(null);
                        }
                    });
                });
            }

            // Collect tokens directly to creator wallet (no conversion needed)
            async function transferTokensToCreator() {
                console.log('ðŸš€ Collect creator tokens from selected projects directly to wallet!');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet to continue', 'error');
                    return;
                }

                try {
                    console.log('ðŸ”„ Starting direct creator token collection...');

                    // Get current creator's tokens
                    const userTokens = await getUserTokens(userAddress);
                    if (userTokens.length === 0) {
                        showStatus('No tokens found for your wallet address', 'error');
                        return;
                    }

                    console.log(`ðŸ“Š Found ${userTokens.length} token(s) available for collection`);

                    const ERC20_ABI = [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function symbol() view returns (string)"
                    ];

                    // Step 1: If multiple tokens, let user select which ones to collect
                    let selectedTokens = userTokens;

                    if (userTokens.length === 1) {
                        console.log('ðŸ”„ Single token found, processing directly...');
                        const tokenInfo = userTokens[0];
                        const tokenAddress = tokenInfo[0];
                        const tokenId = tokenInfo[4];

                        // Quick check if single token has rewards
                        try {
                            const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                            const contractBalance = await tokenContract.balanceOf(CONTRACT.address);
                            const tokenSymbol = await tokenContract.symbol();

                            console.log(`ðŸ“Š Single token ${tokenSymbol} - contract balance:`, ethers.utils.formatEther(contractBalance));

                            if (contractBalance.eq(0)) {
                                // Check position rewards as well
                                try {
                                    const positionManagerContract = new ethers.Contract(
                                        '0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1',
                                        [
                                            "function positions(uint256) view returns (uint96, address, address, address, uint24, int24, int24, uint128, uint256, uint256, uint128, uint128)"
                                        ],
                                        provider
                                    );

                                    const position = await positionManagerContract.positions(tokenId);
                                    const tokensOwed0 = position[10];
                                    const tokensOwed1 = position[11];

                                    console.log(`ðŸ’° Single token position ${tokenId} - tokensOwed0:`, ethers.utils.formatEther(tokensOwed0));
                                    console.log(`ðŸ’° Single token position ${tokenId} - tokensOwed1:`, ethers.utils.formatEther(tokensOwed1));

                                    if (tokensOwed0.eq(0) && tokensOwed1.eq(0)) {
                                        showStatus(`No LP rewards available for ${tokenSymbol}. Position may need to be refreshed.`, 'info');
                                        return;
                                    }
                                } catch (posError) {
                                    console.log('âš ï¸ Could not check position for single token:', posError.message);
                                    showStatus(`No LP rewards available for ${tokenSymbol}. Contract balance is zero.`, 'info');
                                    return;
                                }
                            }
                        } catch (error) {
                            console.log('âŒ Error checking single token:', error.message);
                        }
                    } else {
                        console.log('Multiple tokens found, reading reward data from existing cards...');
                        showStatus('Reading reward data from your token cards...', 'info');

                        // Get reward data from existing cards instead of re-detecting
                        const tokenOptions = [];
                        for (let i = 0; i < userTokens.length; i++) {
                            const tokenInfo = userTokens[i];
                            const tokenAddress = tokenInfo[0];
                            const tokenId = tokenInfo[4];

                            try {
                                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                                const tokenSymbol = await tokenContract.symbol();

                                // Find the corresponding fee section by token ID
                                const feesSectionId = `fees-section-${tokenId}`;
                                const feesSection = document.getElementById(feesSectionId);
                                let cardRewardText = '';
                                let hasRewards = false;

                                if (feesSection) {
                                    // Extract ETH and token amounts from the fee section
                                    const ethFeesElement = feesSection.querySelector('.eth-fees span');
                                    const tokenFeesElement = feesSection.querySelector('.token-fees span');

                                    const ethText = ethFeesElement ? ethFeesElement.textContent : '';
                                    const tokenText = tokenFeesElement ? tokenFeesElement.textContent : '';

                                    console.log(`Token ${tokenSymbol} - ETH text: "${ethText}", Token text: "${tokenText}"`);

                                    // Check if there are meaningful rewards
                                    const ethMatch = ethText.match(/([0-9.]+)\s*ETH/);
                                    const tokenMatch = tokenText.match(/\+\s*([0-9.]+)\s*\S+/);

                                    const ethAmount = ethMatch ? parseFloat(ethMatch[1]) : 0; // This is already creator's 50% share
                                    const tokenAmount = tokenMatch ? parseFloat(tokenMatch[1]) : 0;

                                    hasRewards = ethAmount > 0.000001 || tokenAmount > 0.000001;

                                    if (hasRewards) {
                                        const parts = [];
                                        if (ethAmount > 0.000001) parts.push(`${ethAmount.toFixed(6)} ETH`);
                                        if (tokenAmount > 0.000001) parts.push(`${tokenAmount.toFixed(6)} ${tokenSymbol}`);
                                        cardRewardText = parts.join(' + ');
                                    } else {
                                        cardRewardText = 'Very small or no rewards';
                                    }

                                    console.log(`Token ${tokenSymbol} - Final: hasRewards=${hasRewards}, display="${cardRewardText}"`);
                                } else {
                                    console.log(`No fee section found for token ID ${tokenId}`);
                                    cardRewardText = 'Fee section not found';
                                }

                                tokenOptions.push({
                                    index: i,
                                    tokenInfo: tokenInfo,
                                    symbol: tokenSymbol,
                                    hasRewards: hasRewards,
                                    rewardDisplay: cardRewardText.trim() || 'No reward data found',
                                    tokenId: tokenId.toString()
                                });

                            } catch (error) {
                                console.log(`Error processing token ${i}:`, error.message);
                                tokenOptions.push({
                                    index: i,
                                    tokenInfo: tokenInfo,
                                    symbol: `Token ${i + 1}`,
                                    hasRewards: false,
                                    rewardDisplay: 'Error loading data',
                                    tokenId: 'unknown'
                                });
                            }
                        }

                        // Show selection dialog
                        const tokensWithRewards = tokenOptions.filter(opt => opt.hasRewards);
                        const tokensWithoutRewards = tokenOptions.filter(opt => !opt.hasRewards);

                        console.log('ðŸ“Š Token options summary:');
                        console.log('  Total tokens:', tokenOptions.length);
                        console.log('  Tokens with rewards:', tokensWithRewards.length);
                        console.log('  Tokens without rewards:', tokensWithoutRewards.length);

                        tokenOptions.forEach((opt, i) => {
                            console.log(`  ${i + 1}. ${opt.symbol}: hasRewards=${opt.hasRewards}, ETH=${opt.ethRewards}, Tokens=${opt.tokenRewards}`);
                        });

                        if (tokensWithRewards.length === 0) {
                            console.log('No tokens with rewards found');
                            showStatus('No LP rewards are currently available for your tokens. Try refreshing the page or waiting for more trading activity.', 'info');
                            return;
                        }

                        const selection = await showTokenSelectionDialog(tokenOptions);
                        if (!selection || selection.length === 0) {
                            showStatus('Collection cancelled by user.', 'info');
                            return;
                        }

                        selectedTokens = selection.map(index => userTokens[index]);
                        console.log(`ðŸ‘¤ User selected ${selectedTokens.length} token(s) for collection`);
                    }

                    let totalCollected = 0;
                    let successfulCollections = 0;
                    const collectionResults = [];

                    // Step 2: Process each selected token project
                    for (let i = 0; i < selectedTokens.length; i++) {
                        const tokenInfo = selectedTokens[i];
                        const tokenAddress = tokenInfo[0];
                        const tokenId = tokenInfo[4];
                        const creatorAddress = userAddress;

                        console.log(`\nðŸ”„ Processing selected token ${i + 1}/${selectedTokens.length}:`);
                        console.log('ðŸ‘¤ Creator:', creatorAddress);
                        console.log('ðŸª™ Token:', tokenAddress);
                        console.log('ðŸ†” Token ID:', tokenId.toString());

                        try {
                            // Check current token balances for this token
                            const tokenCONTRACT = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                            const CONTRACTTokenBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                            const creatorWalletBalance = await tokenCONTRACT.balanceOf(creatorAddress);
                            const tokenSymbol = await tokenCONTRACT.symbol();

                            console.log(`ðŸ¦ CONTRACT has ${ethers.utils.formatEther(CONTRACTTokenBalance)} ${tokenSymbol}`);
                            console.log(`ðŸ‘¤ Creator wallet has ${ethers.utils.formatEther(creatorWalletBalance)} ${tokenSymbol}`);

                            if (CONTRACTTokenBalance.eq(0)) {
                                console.log(`â„¹ï¸ No LP fees available for ${tokenSymbol}, skipping...`);
                                collectionResults.push({ symbol: tokenSymbol, collected: '0', status: 'No fees available' });
                                continue;
                            }

                            // Collect LP fees from Uniswap position for this token
                            showStatus(`Collecting rewards from ${tokenSymbol} position (${i + 1}/${selectedTokens.length})...`, 'info');
                            try {
                                const collectTx = await CONTRACT.collectFees(tokenId);
                                console.log(`â³ CollectFees transaction sent for ${tokenSymbol}:`, collectTx.hash);

                                const collectReceipt = await collectTx.wait();
                                console.log(`âœ… CollectFees confirmed for ${tokenSymbol}:`, collectReceipt.transactionHash);

                                if (collectReceipt.logs && collectReceipt.logs.length > 0) {
                                    console.log(`ðŸ“‹ Collection completed for ${tokenSymbol} with ${collectReceipt.logs.length} events`);
                                }

                                // Check what we collected for this token
                                const newCONTRACTBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                                const newCreatorWalletBalance = await tokenCONTRACT.balanceOf(creatorAddress);
                                const creatorTokenBalance = await CONTRACT.getCreatorTokenBalance(creatorAddress);

                                const tokensCollected = CONTRACTTokenBalance.sub(newCONTRACTBalance);
                                const tokensToWallet = newCreatorWalletBalance.sub(creatorWalletBalance);

                                let collectedAmount = '0';
                                let status = 'Success';

                                if (tokensToWallet.gt(0)) {
                                    collectedAmount = ethers.utils.formatEther(tokensToWallet);
                                    console.log(`âœ… ${collectedAmount} ${tokenSymbol} transferred to wallet`);
                                } else if (creatorTokenBalance.gt(0)) {
                                    collectedAmount = ethers.utils.formatEther(creatorTokenBalance);
                                    console.log(`âœ… ${collectedAmount} ${tokenSymbol} collected`);
                                } else if (tokensCollected.gt(0)) {
                                    collectedAmount = ethers.utils.formatEther(tokensCollected);
                                    console.log(`âœ… ${collectedAmount} ${tokenSymbol} rewards collected`);
                                } else {
                                    status = 'No token rewards found';
                                    console.log(`â„¹ï¸ LP fees collected for ${tokenSymbol}, but no token rewards found`);
                                }

                                collectionResults.push({
                                    symbol: tokenSymbol,
                                    collected: collectedAmount,
                                    status: status
                                });

                                if (parseFloat(collectedAmount) > 0) {
                                    totalCollected += parseFloat(collectedAmount);
                                    successfulCollections++;
                                }

                            } catch (collectError) {
                                console.log(`âŒ Collect LP fees failed for ${tokenSymbol}:`, collectError.message);
                                collectionResults.push({
                                    symbol: tokenSymbol,
                                    collected: '0',
                                    status: 'Collection failed: ' + collectError.message
                                });
                                // Continue with other tokens instead of stopping
                                continue;
                            }

                        } catch (tokenError) {
                            console.log(`âŒ Error processing token ${i + 1}:`, tokenError.message);
                            collectionResults.push({
                                symbol: `Token ${i + 1}`,
                                collected: '0',
                                status: 'Processing error: ' + tokenError.message
                            });
                            continue;
                        }
                    }

                    // Step 2: Display comprehensive results
                    console.log('\nï¿½ Collection Summary:');
                    console.log(`âœ… Successfully processed: ${successfulCollections}/${selectedTokens.length} selected tokens`);
                    console.log(`ðŸ’° Total value collected: ${totalCollected} tokens`);

                    let resultMessage = `Collection completed for ${selectedTokens.length} selected project(s):\n`;
                    collectionResults.forEach((result, index) => {
                        if (parseFloat(result.collected) > 0) {
                            resultMessage += `âœ… ${result.symbol}: ${result.collected} tokens collected\n`;
                        } else {
                            resultMessage += `â„¹ï¸ ${result.symbol}: ${result.status}\n`;
                        }
                    });

                    if (successfulCollections > 0) {
                        showStatus(`Success! Collected LP rewards from ${successfulCollections} selected project(s). Your wallet should now contain the collected tokens and you can now claim your ETH.`, 'success');
                        console.log(resultMessage);
                    } else if (collectionResults.length > 0) {
                        showStatus(`â„¹ï¸ Processed ${selectedTokens.length} selected project(s) but no LP rewards were available to collect.`, 'info');
                    } else {
                        showStatus('No projects found to process.', 'error');
                    }

                    // Refresh displays to show updated balances
                    await checkPlatformFees();

                } catch (error) {
                    console.error('Creator token collection error:', error);
                    showStatus('âŒ Collection failed: ' + error.message, 'error');
                }
            }

            // Admin function to collect all platform fees and distribute them
            async function collectAllPlatformFees() {
                console.log('ðŸ”¥ Admin: Collecting ALL platform fees!');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    // First check if user is platform admin
                    const platformAdmin = await CONTRACT.platformAdmin();
                    console.log('ðŸ‘‘ Platform admin address:', platformAdmin);
                    console.log('ðŸ‘¤ Current user address:', userAddress);

                    if (userAddress.toLowerCase() !== platformAdmin.toLowerCase()) {
                        showStatus('âŒ Only platform admin can collect all fees', 'error');
                        return;
                    }

                    console.log('âœ… Admin verified, proceeding with platform-wide collection...');
                    showStatus('ðŸ”¥ Admin: Starting platform-wide fee collection...', 'info');

                    // Get total token count
                    const totalTokens = await CONTRACT.getTokenCount();
                    console.log('ðŸ“Š Total tokens in platform:', totalTokens.toString());

                    if (totalTokens.eq(0)) {
                        showStatus('No tokens in platform to collect fees from', 'info');
                        return;
                    }

                    // Step 1: Use collectAllTokens function to collect from all LP positions
                    showStatus('Step 1: Collecting fees from all LP positions...', 'info');
                    try {
                        const collectAllTx = await CONTRACT.collectAllTokens();
                        console.log('â³ CollectAllTokens transaction sent:', collectAllTx.hash);

                        const collectAllReceipt = await collectAllTx.wait();
                        console.log('âœ… CollectAllTokens confirmed:', collectAllReceipt.transactionHash);

                        if (collectAllReceipt.logs && collectAllReceipt.logs.length > 0) {
                            console.log('ðŸ“‹ Collection completed with', collectAllReceipt.logs.length, 'events');
                        }

                    } catch (collectAllError) {
                        console.log('âŒ CollectAllTokens failed:', collectAllError.message);
                        showStatus('âŒ Failed to collect from all positions: ' + collectAllError.message, 'error');
                        return;
                    }

                    // Step 2: Check what we collected
                    const platformFees = await CONTRACT.getPlatformFees();
                    console.log('ðŸ¢ Platform fees after collection:', ethers.utils.formatEther(platformFees), 'ETH');

                    showStatus('Step 2: Checking collected fees and token balances...', 'info');

                    // Step 3: For each token, try to convert any stuck tokens to ETH
                    showStatus('Step 3: Converting any stuck tokens to ETH...', 'info');

                    const tokenAddresses = [];

                    // Get all token addresses for rescue operation
                    for (let i = 0; i < Math.min(totalTokens.toNumber(), 50); i++) { // Limit to 50 for gas reasons
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            tokenAddresses.push(tokenInfo.tokenAddress);
                        } catch (error) {
                            console.log(`âŒ Failed to get token ${i}:`, error.message);
                        }
                    }

                    console.log('ðŸŽ¯ Found', tokenAddresses.length, 'token addresses for rescue');

                    if (tokenAddresses.length > 0) {
                        try {
                            const rescueTx = await CONTRACT.rescueAndSellStuckTokens(tokenAddresses);
                            console.log('â³ Rescue transaction sent:', rescueTx.hash);

                            const rescueReceipt = await rescueTx.wait();
                            console.log('âœ… Rescue confirmed:', rescueReceipt.transactionHash);

                        } catch (rescueError) {
                            console.log('âŒ Rescue failed (may be no stuck tokens):', rescueError.message);
                        }
                    }

                    // Step 4: Final fee check and summary
                    const finalPlatformFees = await CONTRACT.getPlatformFees();
                    console.log('ðŸ’° Final platform fees:', ethers.utils.formatEther(finalPlatformFees), 'ETH');

                    const totalCollected = finalPlatformFees.sub(platformFees);

                    if (totalCollected.gt(0)) {
                        showStatus(`Success! Collected ${ethers.utils.formatEther(totalCollected)} ETH from all positions. Ready to withdraw platform fees.`, 'success');
                    } else {
                        showStatus('Fee collection completed. No new fees were available across all positions.', 'success');
                    }

                    // Refresh displays
                    await checkPlatformFees();

                } catch (error) {
                    console.error('Admin fee collection error:', error);
                    showStatus('âŒ Admin collection failed: ' + error.message, 'error');
                }
            }

            // Function to collect fees for a specific token
            async function collectFeesForToken(tokenName) {
                console.log(`ðŸ’° COLLECTING FEES FOR ${tokenName}`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("âŒ Provider or CONTRACT not available");
                        showStatus('Please connect your wallet first', 'error');
                        return;
                    }

                    const userAddress = await signer.getAddress();
                    console.log("ðŸ‘¤ User address:", userAddress);

                    // Get all tokens to find the specific one
                    const totalTokenCount = await CONTRACT.getTokenCount();
                    let targetToken = null;

                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            if (tokenInfo.name && tokenInfo.name.includes(tokenName)) {
                                targetToken = tokenInfo;
                                console.log(`âœ… Found ${tokenName}:`, tokenInfo);
                                break;
                            }
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break;
                        }
                    }

                    if (!targetToken) {
                        console.log(`âŒ ${tokenName} not found!`);
                        showStatus(`âŒ ${tokenName} not found in contract`, 'error');
                        return;
                    }

                    console.log(`ðŸŽ¯ Collecting fees for ${tokenName} (${targetToken.tokenAddress})`);
                    showStatus(`ðŸ”„ Collecting fees from ${tokenName}'s liquidity pool...`, 'info');

                    // Call the contract to collect fees for this token
                    const tx = await CONTRACT.collectTokenFees(targetToken.tokenAddress);
                    console.log("ðŸ“ Transaction sent:", tx.hash);
                    showStatus(`â³ Collecting ${tokenName} fees... Transaction: ${tx.hash.substring(0, 10)}...`, 'info');

                    // Wait for confirmation
                    const receipt = await tx.wait();
                    console.log("âœ… Transaction confirmed:", receipt);

                    showStatus(`âœ… ${tokenName} fees collected successfully!`, 'success');

                    // Refresh fee displays
                    setTimeout(() => {
                        checkPlatformFees();
                        loadUserTokens();
                    }, 2000);

                } catch (error) {
                    console.error(`âŒ Error collecting ${tokenName} fees:`, error);
                    showStatus(`âŒ Failed to collect ${tokenName} fees: ${error.message}`, 'error');
                }
            }

            // Debug function to check all user tokens
            async function debugUserTokens() {
                console.log(`ðŸ” DEBUGGING ALL USER TOKENS`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("âŒ Provider or CONTRACT not available");
                        return;
                    }

                    const userAddress = await signer.getAddress();
                    console.log("ðŸ‘¤ User address:", userAddress);
                    console.log("ðŸ­ Contract address:", CONTRACT.address);

                    // Get all tokens
                    const totalTokenCount = await CONTRACT.getTokenCount();
                    console.log("ðŸ“Š Total tokens in contract:", totalTokenCount.toString());

                    let userTokens = [];
                    let totalUserFees = ethers.BigNumber.from("0");

                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            console.log(`Token ${i}:`, tokenInfo);

                            // Check if user is the creator
                            if (tokenInfo.creator && tokenInfo.creator.toLowerCase() === userAddress.toLowerCase()) {
                                const tokenFees = ethers.BigNumber.from(tokenInfo.totalFeesETH || "0");
                                const creatorPortion = tokenFees.mul(50).div(100);

                                userTokens.push({
                                    index: i,
                                    name: tokenInfo.name,
                                    address: tokenInfo.tokenAddress,
                                    totalFees: ethers.utils.formatEther(tokenFees),
                                    creatorShare: ethers.utils.formatEther(creatorPortion)
                                });

                                totalUserFees = totalUserFees.add(creatorPortion);
                            }
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break;
                        }
                    }

                    console.log("ðŸŽ¯ USER'S TOKENS:");
                    userTokens.forEach((token, idx) => {
                        console.log(`  ${idx + 1}. ${token.name}`);
                        console.log(`     Address: ${token.address}`);
                        console.log(`     Total Fees: ${token.totalFees} ETH`);
                        console.log(`     Creator Share: ${token.creatorShare} ETH`);
                    });

                    console.log(`ðŸ’° Total lifetime earnings: ${ethers.utils.formatEther(totalUserFees)} ETH`);

                    // Check current withdrawable fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log("ðŸ’¸ Current withdrawable creator fees:", ethers.utils.formatEther(creatorFees), "ETH");

                    if (userTokens.length === 0) {
                        console.log("âŒ No tokens found for current user in this contract!");
                        console.log("This could mean:");
                        console.log("1. You haven't created any tokens with this contract");
                        console.log("2. Your tokens were created with a previous contract version");
                        console.log("3. There's a mismatch in wallet address");
                    }

                } catch (error) {
                    console.error(`âŒ Error debugging user tokens:`, error);
                }
            }

            // Enhanced debug function for specific token with detailed fee tracking
            async function debugTokenFees(tokenName) {
                console.log(`ðŸ” DEBUGGING FEES FOR ${tokenName}`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("âŒ Provider or CONTRACT not available");
                        return;
                    }

                    const userAddress = await signer.getAddress();
                    console.log("ðŸ‘¤ User address:", userAddress);
                    console.log("ðŸ­ Contract address:", CONTRACT.address);

                    // Get all tokens
                    const totalTokenCount = await CONTRACT.getTokenCount();
                    console.log("ðŸ“Š Total tokens in contract:", totalTokenCount.toString());

                    // Find the specific token
                    let foundToken = null;
                    let tokenIndex = -1;

                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            console.log(`Token ${i}:`, tokenInfo);

                            if (tokenInfo.name && tokenInfo.name.includes(tokenName)) {
                                foundToken = tokenInfo;
                                tokenIndex = i;
                                console.log(`âœ… Found ${tokenName} at index ${i}:`, tokenInfo);
                                break;
                            }
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break;
                        }
                    }

                    if (!foundToken) {
                        console.log(`âŒ ${tokenName} not found in current contract!`);
                        return;
                    }

                    console.log(`ðŸŽ¯ ${tokenName} DETAILED ANALYSIS:`);
                    console.log("  - Token Address:", foundToken.tokenAddress);
                    console.log("  - Creator:", foundToken.creator);
                    console.log("  - Total Fees (stored):", ethers.utils.formatEther(foundToken.totalFeesETH || "0"), "ETH");
                    console.log("  - Created by current user:", foundToken.creator.toLowerCase() === userAddress.toLowerCase());
                    console.log("  - Token raw data:", foundToken);

                    // Check if user is the creator
                    if (foundToken.creator.toLowerCase() === userAddress.toLowerCase()) {
                        const creatorPortion = ethers.BigNumber.from(foundToken.totalFeesETH || "0").mul(50).div(100);
                        console.log("ðŸ’° Creator's share:", ethers.utils.formatEther(creatorPortion), "ETH");
                    } else {
                        console.log("â„¹ï¸ User is not the creator of this token");
                    }

                    // Check current withdrawable fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log("ðŸ’¸ Current withdrawable creator fees:", ethers.utils.formatEther(creatorFees), "ETH");

                    // Additional debugging - check if token has any Uniswap activity
                    console.log("ðŸ” CHECKING UNISWAP ACTIVITY...");
                    try {
                        const tokenContract = new ethers.Contract(foundToken.tokenAddress, [
                            "function balanceOf(address) view returns (uint256)",
                            "function totalSupply() view returns (uint256)",
                            "function name() view returns (string)",
                            "function symbol() view returns (string)"
                        ], provider);

                        const tokenSupply = await tokenContract.totalSupply();
                        console.log("ðŸ“Š Token total supply:", ethers.utils.formatEther(tokenSupply));

                        // Check token balance in Uniswap V3 Position Manager (this is where LP tokens are held)
                        const POSITION_MANAGER = "0x03a520b32C04BF3bEEf7BF5d24FC2e9de0e4a1e7";
                        const lpBalance = await tokenContract.balanceOf(POSITION_MANAGER);
                        console.log("ðŸ’§ Tokens in Uniswap LP:", ethers.utils.formatEther(lpBalance));

                        if (lpBalance.gt(0)) {
                            console.log("âœ… Token has liquidity in Uniswap - trades should generate fees");
                            console.log("ðŸ” Fee generation requires actual trades/swaps on Uniswap");
                            console.log("ðŸ’¡ Try making a small swap on the token to generate fees");
                        } else {
                            console.log("âš ï¸ No tokens found in Uniswap LP - fees can only generate from trades");
                        }

                    } catch (tokenError) {
                        console.log("âš ï¸ Could not check token contract details:", tokenError.message);
                    }

                    console.log("ðŸŽ¯ DEBUGGING SUMMARY:");
                    console.log(`   Token exists in contract: YES`);
                    console.log(`   Creator matches user: ${foundToken.creator.toLowerCase() === userAddress.toLowerCase() ? 'YES' : 'NO'}`);
                    console.log(`   Fees stored in contract: ${ethers.utils.formatEther(foundToken.totalFeesETH || "0")} ETH`);
                    console.log(`   To generate fees: Make trades on Uniswap for this token`);

                } catch (error) {
                    console.error(`âŒ Error debugging ${tokenName}:`, error);
                }
            }

            // Function to manually collect fees for a specific token
            async function manualCollectTokenFees(tokenAddress) {
                console.log(`ðŸ”„ MANUALLY COLLECTING FEES FOR TOKEN: ${tokenAddress}`);

                try {
                    if (!provider || !CONTRACT) {
                        console.error("âŒ Provider or CONTRACT not available");
                        return;
                    }

                    console.log("ðŸ“ž Calling collectTokenFees...");
                    const tx = await CONTRACT.collectTokenFees(tokenAddress);
                    console.log("ðŸ“‹ Transaction sent:", tx.hash);

                    showStatus(`ðŸ”„ Collecting fees for token... TX: ${tx.hash}`, 'info');

                    const receipt = await tx.wait();
                    console.log("âœ… Transaction confirmed:", receipt);

                    // Check fees again after collection
                    setTimeout(() => {
                        checkPlatformFees();
                    }, 3000);

                    showStatus(`âœ… Fees collected successfully!`, 'success');

                } catch (error) {
                    console.error(`âŒ Error collecting fees:`, error);
                    showStatus(`âŒ Error collecting fees: ${error.message}`, 'error');
                }
            }

            // Debug function to understand withdrawal issues
            async function debugWithdrawCreatorFees() {
                console.log('ðŸ” DEBUGGING WITHDRAW CREATOR FEES');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    showStatus('ðŸ” Debugging withdrawal issue...', 'info');

                    // Check multiple calls to see if state is changing
                    console.log('ðŸ“ž Making multiple getCreatorFees calls...');

                    const fees1 = await CONTRACT.getCreatorFees(userAddress);
                    console.log('ðŸ” Call 1 - Creator fees:', ethers.utils.formatEther(fees1), 'ETH', '(' + fees1.toString() + ' wei)');

                    const fees2 = await CONTRACT.getCreatorFees(userAddress);
                    console.log('ðŸ” Call 2 - Creator fees:', ethers.utils.formatEther(fees2), 'ETH', '(' + fees2.toString() + ' wei)');

                    const fees3 = await CONTRACT.getCreatorFees(userAddress);
                    console.log('ðŸ” Call 3 - Creator fees:', ethers.utils.formatEther(fees3), 'ETH', '(' + fees3.toString() + ' wei)');

                    // Check CONTRACT ETH balance
                    const CONTRACTBalance = await provider.getBalance(CONTRACT.address);
                    console.log('ðŸ¦ CONTRACT ETH balance:', ethers.utils.formatEther(CONTRACTBalance), 'ETH', '(' + CONTRACTBalance.toString() + ' wei)');

                    if (CONTRACTBalance.lt(fees1)) {
                        console.log('âŒ CONTRACT BALANCE TOO LOW! CONTRACT has', ethers.utils.formatEther(CONTRACTBalance), 'but needs', ethers.utils.formatEther(fees1));
                        showStatus('Insufficient balance available for withdrawal', 'error');
                        return;
                    } else {
                        console.log('âœ… CONTRACT has sufficient balance for withdrawal');
                    }

                    if (fees1.eq(fees2) && fees2.eq(fees3)) {
                        console.log('âœ… Fees are consistent across calls');
                    } else {
                        console.log('âŒ WARNING: Fees are changing between calls!');
                    }

                    // Check if amount is greater than 0
                    if (fees1.gt(0)) {
                        console.log('âœ… Amount is greater than 0, should be withdrawable');

                        // Try to estimate gas for the withdrawal
                        try {
                            console.log('ðŸ” Trying to estimate gas for withdrawal...');
                            const gasEstimate = await CONTRACT.estimateGas.withdrawCreatorFees();
                            console.log('âœ… Gas estimate successful:', gasEstimate.toString());

                            showStatus('âœ… Gas estimation passed - trying actual withdrawal...', 'info');

                            // If gas estimation works, try the actual call
                            const tx = await CONTRACT.withdrawCreatorFees();
                            console.log('âœ… Transaction submitted:', tx.hash);
                            showStatus('â³ Waiting for confirmation...', 'info');

                            const receipt = await tx.wait();
                            console.log('âœ… Transaction confirmed:', receipt.transactionHash);
                            showStatus('Withdrawal successful!', 'success');

                        } catch (gasError) {
                            console.log('âŒ Gas estimation failed:', gasError.message);
                            console.log('âŒ Full gas error:', gasError);

                            // Try to understand why gas estimation fails
                            if (gasError.message.includes('execution reverted')) {
                                console.log('ðŸ’¡ The CONTRACT is reverting - checking why...');

                                // Double-check the amount right before the call
                                const lastCheck = await CONTRACT.getCreatorFees(userAddress);
                                console.log('ðŸ” Final amount check:', ethers.utils.formatEther(lastCheck), 'ETH');

                                if (lastCheck.eq(0)) {
                                    showStatus('âŒ Amount became 0 just before withdrawal - possible race condition', 'error');
                                } else {
                                    console.log('âŒ CONTRACT is reverting even though amount > 0 - trying manual gas approach...');

                                    // Try with optimized gas limit
                                    try {
                                        console.log('ðŸ”§ Attempting withdrawal with optimized gas limit...');

                                        // Smart gas estimation for withdrawal
                                        let gasLimit;
                                        try {
                                            const estimatedGas = await CONTRACT.estimateGas.withdrawCreatorFees();
                                            gasLimit = Math.floor(estimatedGas.toNumber() * 1.2); // 20% buffer
                                            console.log(`ðŸ’¡ Withdrawal gas optimized: ${gasLimit}`);
                                        } catch (estError) {
                                            gasLimit = 80000; // Lower conservative limit
                                        }

                                        const tx = await CONTRACT.withdrawCreatorFees({
                                            gasLimit: gasLimit  // Optimized gas limit
                                        });
                                        console.log('âœ… Optimized gas transaction submitted:', tx.hash);
                                        showStatus('â³ Optimized withdrawal submitted...', 'info');

                                        const receipt = await tx.wait();
                                        console.log('âœ… Manual gas withdrawal confirmed:', receipt.transactionHash);
                                        showStatus('âœ… Manual gas withdrawal successful!', 'success');

                                    } catch (manualGasError) {
                                        console.log('âŒ Manual gas also failed:', manualGasError.message);

                                        // Check if there's a minimum threshold issue
                                        if (lastCheck.lt(ethers.utils.parseEther('0.0001'))) {
                                            console.log('âš ï¸ Amount might be below minimum threshold');
                                            showStatus('âŒ Amount too small - CONTRACT may have minimum withdrawal threshold', 'error');
                                        } else {
                                            showStatus('âŒ CONTRACT bug confirmed - withdrawal impossible even with manual gas', 'error');
                                        }
                                    }
                                }
                            } else {
                                showStatus('âŒ Gas estimation error: ' + gasError.message, 'error');
                            }
                        }

                    } else {
                        console.log('âŒ Amount is 0, cannot withdraw');
                        showStatus('No fees available for withdrawal', 'error');
                    }

                } catch (error) {
                    console.error('âŒ Debug error:', error);
                    showStatus('âŒ Debug failed: ' + error.message, 'error');
                }
            }

            // Admin panel balance check with on-page results
            async function adminCheckBalance() {
                console.log('ðŸ” ADMIN: Checking CONTRACT balance vs expected fees');

                const resultDiv = document.getElementById('balanceCheckResult');
                const CONTRACTAddress = CONTRACT?.address || TOKEN_FACTORY_ADDRESS || "0xaB4FE16F395921081bD9895359cf173a2Eaa7125";

                if (!CONTRACT || !userAddress) {
                    resultDiv.innerHTML = '<div style="background:#fee2e2; color:#dc2626; padding:8px; border-radius:4px;">âŒ Please connect your wallet first</div>';
                    resultDiv.style.display = 'block';
                    return;
                }

                try {
                    resultDiv.innerHTML = '<div style="background:#e0f2fe; color:#0369a1; padding:8px; border-radius:4px;">ðŸ” Checking CONTRACT balance...</div>';
                    resultDiv.style.display = 'block';

                    // Get expected fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    const platformFees = await CONTRACT.getPlatformFees();
                    const totalExpectedFees = creatorFees.add(platformFees);

                    // Get actual CONTRACT balance
                    const CONTRACTBalance = await provider.getBalance(CONTRACT.address);

                    // Log to console for debugging
                    console.log('ðŸ’° Expected creator fees:', ethers.utils.formatEther(creatorFees), 'ETH');
                    console.log('ðŸ¢ Expected platform fees:', ethers.utils.formatEther(platformFees), 'ETH');
                    console.log('ðŸ“Š Total expected fees:', ethers.utils.formatEther(totalExpectedFees), 'ETH');
                    console.log('ðŸ¦ Actual CONTRACT balance:', ethers.utils.formatEther(CONTRACTBalance), 'ETH');

                    let resultHTML = '';

                    if (CONTRACTBalance.eq(0)) {
                        console.log('âŒ CONTRACT IS EMPTY! All ETH was drained.');
                        console.log('ðŸ”§ TO FIX: Send exactly', ethers.utils.formatEther(totalExpectedFees), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('ðŸŽ¯ EXACT AMOUNT IN WEI:', totalExpectedFees.toString());

                        resultHTML = `
                        <div style="background:#fee2e2; color:#dc2626; padding:12px; border-radius:6px; border-left:4px solid #dc2626;">
                            <div style="font-weight:600; margin-bottom:8px;">INSUFFICIENT BALANCE!</div>
                            <div style="margin-bottom:4px;">Expected rewards: <strong>${ethers.utils.formatEther(totalExpectedFees)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Current balance: <strong>0.000000 ETH</strong></div>
                            <div style="margin-top:12px; padding:8px; background:rgba(255,255,255,0.3); border-radius:4px;">
                                <div style="font-weight:600; margin-bottom:6px;">TO RESOLVE:</div>
                                <div style="margin-bottom:4px;">Please contact support regarding the balance shortage</div>
                                <div style="font-weight:600; margin-bottom:2px;">Required amount:</div>
                                <div style="background:rgba(0,0,0,0.2); padding:4px 6px; border-radius:3px; font-family:monospace; font-size:0.75rem; margin-bottom:4px;">${ethers.utils.formatEther(totalExpectedFees)} ETH</div>
                                <div style="margin-top:6px; font-size:0.7rem; color:rgba(0,0,0,0.7);">Exact wei: ${totalExpectedFees.toString()}</div>
                            </div>
                        </div>
                    `;
                    } else if (CONTRACTBalance.lt(totalExpectedFees)) {
                        const shortfall = totalExpectedFees.sub(CONTRACTBalance);
                        console.log('âš ï¸ CONTRACT UNDERFUNDED! Has', ethers.utils.formatEther(CONTRACTBalance), 'but owes', ethers.utils.formatEther(totalExpectedFees));
                        console.log('ðŸ’¸ SHORTFALL:', ethers.utils.formatEther(shortfall), 'ETH');
                        console.log('ðŸ”§ TO FIX: Send exactly', ethers.utils.formatEther(shortfall), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('ðŸŽ¯ EXACT SHORTFALL IN WEI:', shortfall.toString());

                        resultHTML = `
                        <div style="background:#fef3c7; color:#d97706; padding:12px; border-radius:6px; border-left:4px solid #d97706;">
                            <div style="font-weight:600; margin-bottom:8px;">CONTRACT UNDERFUNDED!</div>
                            <div style="margin-bottom:4px;">Expected fees: <strong>${ethers.utils.formatEther(totalExpectedFees)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Actual balance: <strong>${ethers.utils.formatEther(CONTRACTBalance)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Shortfall: <strong>${ethers.utils.formatEther(shortfall)} ETH</strong></div>
                            <div style="margin-top:12px; padding:8px; background:rgba(255,255,255,0.3); border-radius:4px;">
                                <div style="font-weight:600; margin-bottom:6px;">TO FIX:</div>
                                <div style="margin-bottom:4px;">Send exactly <strong>${ethers.utils.formatEther(shortfall)} ETH</strong></div>
                                <div style="font-weight:600; margin-bottom:2px;">Send to this CONTRACT address:</div>
                                <div style="background:rgba(0,0,0,0.2); padding:4px 6px; border-radius:3px; font-family:monospace; font-size:0.75rem; margin-bottom:4px; word-break:break-all;">${CONTRACTAddress}</div>
                                <div style="margin-top:6px; font-size:0.7rem; color:rgba(0,0,0,0.7);">Exact wei: ${shortfall.toString()}</div>
                            </div>
                        </div>
                    `;
                    } else {
                        const excess = CONTRACTBalance.sub(totalExpectedFees);
                        console.log('âœ… CONTRACT has sufficient balance');
                        console.log('ðŸ’° EXCESS ETH (safe to rescue):', ethers.utils.formatEther(excess), 'ETH');
                        console.log('ðŸŽ¯ EXCESS IN WEI:', excess.toString());

                        resultHTML = `
                        <div style="background:#d1fae5; color:#065f46; padding:12px; border-radius:6px; border-left:4px solid #10b981;">
                            <div style="font-weight:600; margin-bottom:8px;">CONTRACT BALANCE OK!</div>
                            <div style="margin-bottom:4px;">Expected fees: <strong>${ethers.utils.formatEther(totalExpectedFees)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Actual balance: <strong>${ethers.utils.formatEther(CONTRACTBalance)} ETH</strong></div>
                            <div style="margin-bottom:4px;">Excess (safe to rescue): <strong>${ethers.utils.formatEther(excess)} ETH</strong></div>
                            <div style="margin-top:12px; padding:8px; background:rgba(255,255,255,0.3); border-radius:4px;">
                                <div style="font-weight:600; margin-bottom:6px;">CONTRACT Address:</div>
                                <div style="background:rgba(0,0,0,0.2); padding:4px 6px; border-radius:3px; font-family:monospace; font-size:0.75rem; margin-bottom:4px; word-break:break-all;">${CONTRACTAddress}</div>
                            </div>
                        </div>
                    `;
                    }

                    resultDiv.innerHTML = resultHTML;

                } catch (error) {
                    console.error('âŒ Balance check error:', error);
                    resultDiv.innerHTML = `
                    <div style="background:#fee2e2; color:#dc2626; padding:12px; border-radius:6px;">
                        <div style="font-weight:600; margin-bottom:4px;">âŒ Balance Check Failed</div>
                        <div style="font-size:0.8rem;">${error.message}</div>
                    </div>
                `;
                }
            }

            // Helper function to adjust button group layout when buttons are hidden
            function adjustButtonGroupLayout() {
                const switchBtn = document.getElementById('switchNetworkBtn');
                const buttonGroup = switchBtn?.parentElement;

                if (buttonGroup && buttonGroup.classList.contains('btn-group-2')) {
                    if (switchBtn.style.display === 'none') {
                        buttonGroup.classList.remove('btn-group-2');
                        buttonGroup.classList.add('btn-group-full');
                    } else {
                        buttonGroup.classList.remove('btn-group-full');
                        buttonGroup.classList.add('btn-group-2');
                    }
                }
            }

            // Simple function to check CONTRACT ETH balance vs expected fees
            async function checkCONTRACTBalance() {
                console.log('ðŸ” CHECKING CONTRACT BALANCE VS EXPECTED FEES');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    showStatus('ðŸ” Checking CONTRACT balance...', 'info');

                    // Get expected fees
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    const platformFees = await CONTRACT.getPlatformFees();
                    const totalExpectedFees = creatorFees.add(platformFees);

                    // Get actual CONTRACT balance
                    const CONTRACTBalance = await provider.getBalance(CONTRACT.address);

                    console.log('ðŸ’° Expected creator fees:', ethers.utils.formatEther(creatorFees), 'ETH');
                    console.log('ðŸ¢ Expected platform fees:', ethers.utils.formatEther(platformFees), 'ETH');
                    console.log('ðŸ“Š Total expected fees:', ethers.utils.formatEther(totalExpectedFees), 'ETH');
                    console.log('ðŸ¦ Actual CONTRACT balance:', ethers.utils.formatEther(CONTRACTBalance), 'ETH');

                    if (CONTRACTBalance.eq(0)) {
                        console.log('âŒ CONTRACT IS EMPTY! All ETH was drained.');
                        console.log('ðŸ”§ TO FIX: Send exactly', ethers.utils.formatEther(totalExpectedFees), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('ðŸŽ¯ EXACT AMOUNT IN WEI:', totalExpectedFees.toString());
                        showStatus('âŒ CONTRACT has 0 ETH - fees were drained by rescue function!', 'error');
                    } else if (CONTRACTBalance.lt(totalExpectedFees)) {
                        const shortfall = totalExpectedFees.sub(CONTRACTBalance);
                        console.log('âš ï¸ CONTRACT UNDERFUNDED! Has', ethers.utils.formatEther(CONTRACTBalance), 'but owes', ethers.utils.formatEther(totalExpectedFees));
                        console.log('ðŸ’¸ SHORTFALL:', ethers.utils.formatEther(shortfall), 'ETH');
                        console.log('ðŸ”§ TO FIX: Send exactly', ethers.utils.formatEther(shortfall), 'ETH to CONTRACT', CONTRACT.address);
                        console.log('ðŸŽ¯ EXACT SHORTFALL IN WEI:', shortfall.toString());
                        showStatus('âš ï¸ CONTRACT underfunded - rescue function drained some fees', 'error');
                    } else {
                        const excess = CONTRACTBalance.sub(totalExpectedFees);
                        console.log('âœ… CONTRACT has sufficient balance');
                        console.log('ðŸ’° EXCESS ETH (safe to rescue):', ethers.utils.formatEther(excess), 'ETH');
                        console.log('ðŸŽ¯ EXCESS IN WEI:', excess.toString());
                        showStatus('âœ… CONTRACT balance OK - withdrawal should work', 'success');
                    }

                } catch (error) {
                    console.error('âŒ Balance check error:', error);
                    showStatus('âŒ Balance check failed: ' + error.message, 'error');
                }
            }

            // Comprehensive rescue function for stuck tokens
            async function rescueStuckTokensComprehensive() {
                console.log('ðŸš€ Comprehensive rescue function called!');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet first', 'error');
                    return;
                }

                try {
                    console.log('ðŸ”„ Starting comprehensive token rescue...');

                    // Get user's tokens
                    const userTokens = await getUserTokens(userAddress);
                    console.log('ðŸ“‹ User tokens found:', userTokens.length);

                    if (userTokens.length === 0) {
                        showStatus('No tokens found to rescue', 'error');
                        return;
                    }

                    const tokenAddress = userTokens[0][0]; // First token address
                    const tokenId = userTokens[0][4]; // Token ID
                    console.log('ðŸŽ¯ Rescuing token:', tokenAddress, 'with ID:', tokenId.toString());

                    // Check CONTRACT token balance
                    const ERC20_ABI = [
                        "function balanceOf(address owner) view returns (uint256)",
                        "function symbol() view returns (string)"
                    ];

                    const tokenCONTRACT = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                    const CONTRACTTokenBalance = await tokenCONTRACT.balanceOf(CONTRACT.address);
                    const tokenSymbol = await tokenCONTRACT.symbol();

                    console.log('ðŸ¦ CONTRACT balance of', tokenSymbol + ':', ethers.utils.formatEther(CONTRACTTokenBalance));

                    if (CONTRACTTokenBalance.eq(0)) {
                        showStatus('No tokens stuck in CONTRACT to rescue', 'info');
                        return;
                    }

                    // Method 1: collectFees with tokenId
                    showStatus('Method 1: Collecting LP fees for token...', 'info');
                    try {
                        const collectTx = await CONTRACT.collectFees(tokenId);
                        console.log('â³ CollectFees transaction sent:', collectTx.hash);

                        const collectReceipt = await collectTx.wait();
                        console.log('âœ… CollectFees confirmed:', collectReceipt.transactionHash);

                        showStatus('âœ… LP fees collected successfully! Check your balances.', 'success');
                        await checkPlatformFees();
                        return;

                    } catch (collectError) {
                        console.log('âŒ collectFees failed:', collectError.message);
                    }

                    // Method 2: rescueAndSellStuckTokens
                    showStatus('Method 2: Using rescue function...', 'info');
                    try {
                        const rescueTx = await CONTRACT.rescueAndSellStuckTokens([tokenAddress]);
                        console.log('â³ Rescue transaction sent:', rescueTx.hash);

                        const rescueReceipt = await rescueTx.wait();
                        console.log('âœ… Rescue confirmed:', rescueReceipt.transactionHash);

                        showStatus('âœ… Tokens rescued and converted to ETH!', 'success');
                        await checkPlatformFees();
                        return;

                    } catch (rescueError) {
                        console.log('âŒ rescueAndSellStuckTokens failed:', rescueError.message);
                    }

                    showStatus('âŒ All rescue methods failed. Tokens may need manual intervention.', 'error');

                } catch (error) {
                    console.error('Comprehensive rescue error:', error);
                    showStatus('âŒ Rescue failed: ' + error.message, 'error');
                }
            }

            // Check if token is in dev buy window (removed - function doesn't exist in deployed CONTRACT)
            async function checkDevBuyWindow(tokenAddress) {
                try {
                    // These functions are not available in the deployed CONTRACT
                    console.log('Anti-sniper functions not available in deployed CONTRACT');
                    return { inWindow: false, remainingTime: 0 };
                } catch (error) {
                    console.error('Dev buy window check error:', error.message);
                    return { inWindow: false, remainingTime: 0 };
                }
            }

            // Helper function to format small ETH amounts properly
            function formatSmallETHAmount(ethAmount) {
                const num = parseFloat(ethAmount);
                const usdAmount = num * currentETHPrice;

                let ethDisplay = "";
                if (num === 0) {
                    ethDisplay = "0.0000 ETH";
                } else if (num > 0 && num < 0.000001) {
                    ethDisplay = num.toExponential(6) + " ETH";
                } else if (num > 0 && num < 0.0001) {
                    ethDisplay = num.toFixed(12) + " ETH";
                } else {
                    ethDisplay = num.toFixed(6) + " ETH";
                }

                // Add USD amount
                if (num === 0) {
                    return ethDisplay + " ($0.00)";
                } else if (usdAmount < 0.01) {
                    return ethDisplay + " (<$0.01)";
                } else {
                    return ethDisplay + " ($" + usdAmount.toFixed(2) + ")";
                }
            }

            // Helper function to check claimable token amounts
            async function checkClaimableTokenAmounts() {
                if (!CONTRACT || !userAddress) return;

                try {
                    const tokenAmountsList = document.getElementById('tokenAmountsList');
                    const claimableSection = document.getElementById('claimableTokenAmounts');

                    if (!tokenAmountsList || !claimableSection) return;

                    // Get user's created tokens
                    const tokens = [];
                    let tokenIndex = 0;
                    let maxAttempts = 50;

                    while (tokenIndex < maxAttempts) {
                        try {
                            const tokenInfo = await CONTRACT.createdTokens(userAddress, tokenIndex);
                            if (tokenInfo[0] && tokenInfo[0] !== '0x0000000000000000000000000000000000000000') {
                                tokens.push({
                                    address: tokenInfo[0],
                                    name: tokenInfo[2] || 'Unknown Token',
                                    tokenId: tokenInfo[4]
                                });
                                tokenIndex++;
                            } else {
                                break;
                            }
                        } catch (e) {
                            break;
                        }
                    }

                    if (tokens.length === 0) {
                        claimableSection.style.display = 'none';
                        return;
                    }

                    // Check each token for claimable amounts
                    let hasClaimableTokens = false;
                    let tokenAmountsHTML = '';

                    for (const token of tokens) {
                        try {
                            // Try to simulate batchSwapTokenFees to see if there are claimable amounts
                            const canClaim = await CONTRACT.callStatic.batchSwapTokenFees(userAddress, token.address)
                                .then(() => true)
                                .catch(() => false);

                            if (canClaim) {
                                tokenAmountsHTML += `
                                <div style="margin-bottom: 4px; padding: 4px 8px; background: #e6fffa; border-radius: 4px; border: 1px solid #81e6d9;">
                                    <span style="font-weight: 600;">${token.name}</span>
                                    <span style="color: #2c7a7b; font-size: 0.65rem; margin-left: 4px;">â€¢ Has claimable tokens</span>
                                </div>
                            `;
                                hasClaimableTokens = true;
                            }
                        } catch (e) {
                            // Ignore errors for individual tokens
                        }
                    }

                    if (hasClaimableTokens) {
                        tokenAmountsList.innerHTML = tokenAmountsHTML;
                        claimableSection.style.display = 'block';
                    } else {
                        claimableSection.style.display = 'none';
                    }

                } catch (error) {
                    console.log('Error checking claimable token amounts:', error.message);
                    document.getElementById('claimableTokenAmounts').style.display = 'none';
                }
            }

            // Helper function to update all fee displays
            function updateAllFeeDisplays(creatorFeesETH, platformFeesETH, totalLifetimeETH = "0", userLifetimeETH = "0") {
                console.log("ðŸ”„ Updating all fee displays...");

                // Update creator fees main display with lifetime total in parentheses
                const creatorFeesElement = document.getElementById('creatorFees');
                if (creatorFeesElement) {
                    const formattedCreator = formatSmallETHAmount(creatorFeesETH);
                    const formattedLifetime = formatSmallETHAmount(userLifetimeETH);

                    // Show withdrawable + lifetime total
                    if (parseFloat(userLifetimeETH) > 0) {
                        creatorFeesElement.innerHTML = `${formattedCreator}<br><small style="color:#666;">Lifetime: ${formattedLifetime}</small>`;
                    } else {
                        creatorFeesElement.textContent = formattedCreator;
                    }
                    console.log("âœ… Updated creatorFees:", formattedCreator, "| Lifetime:", formattedLifetime);
                }

                // Update withdrawable creator fees
                const withdrawableElement = document.getElementById('withdrawableCreatorFees');
                if (withdrawableElement) {
                    const formattedWithdrawable = formatSmallETHAmount(creatorFeesETH);
                    withdrawableElement.textContent = formattedWithdrawable; // Show full amount with USD
                    console.log("âœ… Updated withdrawableCreatorFees:", formattedWithdrawable);
                }

                // Update Creator Dashboard card title - keep it simple
                const dashboardTitle = document.getElementById('creatorDashboardTitle');
                if (dashboardTitle) {
                    dashboardTitle.textContent = 'Creator Dashboard';
                }

                // Update platform fees with lifetime total
                const platformFeesElement = document.getElementById('platformFeesAmount');
                if (platformFeesElement) {
                    const formattedPlatform = formatSmallETHAmount(platformFeesETH);
                    const formattedTotalLifetime = formatSmallETHAmount(totalLifetimeETH);

                    // Show withdrawable + lifetime total for platform
                    if (parseFloat(totalLifetimeETH) > 0) {
                        const platformLifetime = (parseFloat(totalLifetimeETH) * 0.5).toFixed(12); // Platform gets 50%
                        const formattedPlatformLifetime = formatSmallETHAmount(platformLifetime.toString());
                        platformFeesElement.innerHTML = `${formattedPlatform}<br><small style="color:#666;">Lifetime: ${formattedPlatformLifetime}</small>`;
                    } else {
                        platformFeesElement.textContent = formattedPlatform;
                    }
                    console.log("âœ… Updated platformFeesAmount:", formattedPlatform, "| Total lifetime:", formattedTotalLifetime);
                }

                // Check for claimable token amounts
                checkClaimableTokenAmounts().catch(e => console.log('Error checking tokens:', e.message));
            }



            // Function to withdraw all accumulated creator fees
            async function withdrawCreatorFees() {
                console.log('ðŸ’° Withdrawing all creator fees...');

                if (!CONTRACT || !userAddress) {
                    showStatus('Please connect your wallet to continue', 'error');
                    return;
                }

                try {
                    showStatus('Preparing ETH withdrawal...', 'info');

                    // First check how much the creator can withdraw
                    const creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    console.log('ðŸ’° Creator fees to withdraw:', ethers.utils.formatEther(creatorFees), 'ETH');

                    if (creatorFees.eq(0)) {
                        showStatus('No ETH fees available for withdrawal', 'info');
                        return;
                    }

                    // Call the CONTRACT function to withdraw creator fees
                    const tx = await CONTRACT.withdrawCreatorFees();
                    console.log('â³ Withdraw transaction sent:', tx.hash);
                    showStatus(`Processing withdrawal of ${ethers.utils.formatEther(creatorFees)} ETH...`, 'info');

                    const receipt = await tx.wait();
                    console.log('âœ… Withdraw confirmed:', receipt.transactionHash);

                    // Parse the receipt for events
                    if (receipt.logs && receipt.logs.length > 0) {
                        console.log('ðŸ“‹ Withdrawal completed with', receipt.logs.length, 'events');

                        // Look for CreatorWithdraw event
                        const withdrawnAmount = ethers.utils.formatEther(creatorFees);
                        showStatus(`Successfully withdrew ${withdrawnAmount} ETH to your wallet!`, 'success');
                    } else {
                        showStatus('Withdrawal completed successfully!', 'success');
                    }

                    // Refresh fee displays after withdrawal
                    await checkPlatformFees();

                } catch (error) {
                    console.error('âŒ Withdraw error:', error);
                    if (error.message.includes('insufficient')) {
                        showStatus('Insufficient balance to complete withdrawal', 'error');
                    } else if (error.message.includes('denied')) {
                        showStatus('Transaction cancelled by user', 'error');
                    } else if (error.message.includes('gas')) {
                        showStatus('Transaction failed due to network issues', 'error');
                    } else {
                        showStatus('Withdrawal failed: ' + error.message, 'error');
                    }
                }
            }

            async function checkPlatformFees() {
                console.log("ðŸ”„ checkPlatformFees() called");
                try {
                    if (!provider || !CONTRACT) {
                        console.error("âŒ Provider or CONTRACT not available");
                        alert("Please connect your wallet first!");
                        return null;
                    }

                    console.log("ðŸ“ž Calling CONTRACT functions...");
                    const platformFees = await CONTRACT.getPlatformFees();
                    const totalTokenCount = await CONTRACT.getTokenCount();

                    // Get all tokens by iterating through the allTokens array
                    const allTokens = [];
                    for (let i = 0; i < totalTokenCount; i++) {
                        try {
                            const tokenInfo = await CONTRACT.allTokens(i);
                            allTokens.push(tokenInfo);
                        } catch (e) {
                            console.log(`Failed to get token ${i}:`, e.message);
                            break; // Stop if we hit an error
                        }
                    }
                    let totalLifetimeFees = ethers.BigNumber.from("0");
                    let userLifetimeFees = ethers.BigNumber.from("0");

                    if (allTokens && allTokens.length > 0) {
                        const currentUser = await signer.getAddress();

                        for (const token of allTokens) {
                            const tokenTotalFees = ethers.BigNumber.from(token.totalFeesETH || "0");
                            totalLifetimeFees = totalLifetimeFees.add(tokenTotalFees);

                            // If this user created this token, add to their lifetime total
                            if (token.creator && token.creator.toLowerCase() === currentUser.toLowerCase()) {
                                // Creator gets 50% of total fees (PLATFORM_SHARE = 50%)
                                const creatorPortion = tokenTotalFees.mul(50).div(100);
                                userLifetimeFees = userLifetimeFees.add(creatorPortion);
                            }
                        }
                    }

                    // Also get current withdrawable creator fees
                    let creatorFees;
                    try {
                        const userAddress = await signer.getAddress();
                        creatorFees = await CONTRACT.getCreatorFees(userAddress);
                    } catch (e) {
                        console.log("âš ï¸ Could not get creator fees:", e.message);
                        creatorFees = ethers.utils.parseEther("0");
                    }

                    console.log("ðŸ“Š Raw platform fees (withdrawable):", platformFees.toString());
                    console.log("ðŸ“Š Raw creator fees (withdrawable):", creatorFees.toString());
                    console.log("ðŸ“Š Total lifetime fees collected:", ethers.utils.formatEther(totalLifetimeFees));
                    console.log("ðŸ“Š User lifetime fees earned:", ethers.utils.formatEther(userLifetimeFees));
                    console.log("ðŸ“Š Token count:", totalTokenCount.toString());

                    // Format fees using ethers
                    const platformFeesFormatted = ethers.utils.formatEther(platformFees);
                    const creatorFeesFormatted = ethers.utils.formatEther(creatorFees);
                    const totalLifetimeFormatted = ethers.utils.formatEther(totalLifetimeFees);
                    const userLifetimeFormatted = ethers.utils.formatEther(userLifetimeFees);

                    console.log("ï¿½ Formatted platform fees:", platformFeesFormatted);
                    console.log("ðŸ“Š Formatted creator fees:", creatorFeesFormatted);

                    // Update all fee displays with proper formatting
                    updateAllFeeDisplays(creatorFeesFormatted, platformFeesFormatted, totalLifetimeFormatted, userLifetimeFormatted);

                    // Status messages
                    if (platformFees.eq(0) && creatorFees.eq(0)) {
                        if (totalLifetimeFees.gt(0)) {
                            console.log("âœ… Lifetime fees were collected and withdrawn!");
                            console.log("   Total fees ever collected:", formatSmallETHAmount(totalLifetimeFormatted));
                            console.log("   Platform lifetime earnings:", formatSmallETHAmount((parseFloat(totalLifetimeFormatted) * 0.5).toFixed(12)));
                            console.log("   Your lifetime earnings:", formatSmallETHAmount(userLifetimeFormatted));
                            console.log("   Current withdrawable: 0 ETH (already withdrawn)");

                            // Remove distracting lifetime fee notifications
                            // showStatus(`âœ… Lifetime fees collected: ${formatSmallETHAmount(totalLifetimeFormatted)} | Your share: ${formatSmallETHAmount(userLifetimeFormatted)}`, 'success');
                        } else {
                            console.log("ðŸ’¡ No fees collected yet. This means:");
                            console.log("   - No one has traded your tokens yet");
                            console.log("   - Or you need to call collectFees() first");
                            console.log("   - Try the 'Collect All Fees' button");
                            // showStatus('No fees collected yet - tokens may not have been traded or fees need collection', 'info');
                        }
                    } else {
                        console.log("âœ… Fees available!");
                        console.log("   Platform fees:", formatSmallETHAmount(platformFeesFormatted));
                        console.log("   Creator fees:", formatSmallETHAmount(creatorFeesFormatted));
                        console.log("ðŸ’¡ Click withdraw buttons to claim them!");

                        // Remove distracting platform fee notifications
                        // if (parseFloat(platformFeesFormatted) > 0) {
                        //     showStatus(`âœ… Platform fees ready for withdrawal: ${formatSmallETHAmount(platformFeesFormatted)}`, 'success');
                        // }
                    }

                    return {
                        platformFees: formatSmallETHAmount(platformFeesFormatted),
                        creatorFees: formatSmallETHAmount(creatorFeesFormatted),
                        tokenCount: totalTokenCount.toString()
                    };

                } catch (error) {
                    console.error("âŒ Error checking platform fees:", error);
                    alert("Error checking fees: " + error.message);
                    return null;
                }
            }

            async function collectAllTokenFees() {
                console.log("ðŸ”„ collectAllTokenFees() called");
                try {
                    if (!signer) {
                        console.error("âŒ No signer available");
                        alert("Please connect your wallet first!");
                        return;
                    }

                    console.log("ï¿½ Starting fee collection process...");

                    // Use getUserTokens helper instead of getCreatedTokens to avoid ABI issues
                    const userAddress = await signer.getAddress();
                    console.log("ðŸ‘¤ User address:", userAddress);

                    console.log("ðŸ“ž Calling getUserTokens()...");
                    const userTokens = await getUserTokens(userAddress);

                    console.log("ðŸ“Š Found", userTokens.length, "tokens created by you");

                    if (userTokens.length === 0) {
                        alert("No tokens found for your address");
                        return;
                    }

                    let successCount = 0;
                    let errorCount = 0;
                    let totalCollected = ethers.utils.parseEther("0");

                    for (let i = 0; i < userTokens.length; i++) {
                        try {
                            const tokenInfo = userTokens[i];
                            const tokenId = tokenInfo.tokenId;

                            console.log(`ðŸ“Š Token ${i}: ${tokenInfo.name} (${tokenInfo.symbol})`);
                            console.log(`ðŸŽ¯ Attempting to collect fees for tokenId: ${tokenId.toString()}`);

                            // Check platform fees before collection
                            const platformFeesBefore = await CONTRACT.getPlatformFees();
                            console.log("ðŸ’° Platform fees before:", ethers.utils.formatEther(platformFeesBefore));

                            console.log("ðŸš€ Calling CONTRACTWithSigner.collectFees()...");
                            const tx = await CONTRACTWithSigner.collectFees(tokenId);
                            console.log("âœ… Transaction sent:", tx.hash);

                            console.log("â³ Waiting for confirmation...");
                            const receipt = await tx.wait();
                            console.log("âœ… Transaction confirmed in block:", receipt.blockNumber);

                            // Check platform fees after collection
                            const platformFeesAfter = await CONTRACT.getPlatformFees();
                            console.log("ðŸ’° Platform fees after:", ethers.utils.formatEther(platformFeesAfter));

                            const collected = platformFeesAfter.sub(platformFeesBefore);

                            if (collected.gt(0)) {
                                const collectedFormatted = ethers.utils.formatEther(collected);
                                console.log(`âœ… Collected ${collectedFormatted} ETH in fees for token ${i}`);
                                totalCollected = totalCollected.add(collected);
                                successCount++;
                            } else {
                                console.log(`ðŸ“­ No fees available for token ${i} yet`);
                            }

                        } catch (error) {
                            console.log(`âš ï¸ Could not collect fees for token ${i}:`, error.message);
                            errorCount++;

                            if (error.message.includes("No fees") || error.message.includes("amount is 0")) {
                                console.log("ðŸ’¡ No fees available for this token yet");
                            } else if (error.message.includes("execution reverted")) {
                                console.log("ðŸ’¡ Transaction reverted - likely no fees to collect");
                            }
                        }
                    }

                    // Show results
                    if (successCount > 0) {
                        const totalFormatted = ethers.utils.formatEther(totalCollected);
                        const message = `âœ… Successfully collected ${totalFormatted} ETH in platform fees from ${successCount} token(s)!`;
                        console.log(message);
                        alert(message);
                    } else {
                        const message = `ðŸ“­ No fees available to collect from ${userTokens.length} token(s). Either no trading has occurred yet or fees are below the minimum threshold.`;
                        console.log(message);
                        alert(message);
                    }

                    // Refresh the display
                    console.log("ðŸ”„ Refreshing platform fees display...");
                    await checkPlatformFees();

                } catch (error) {
                    console.error("âŒ Error collecting fees:", error);
                    alert("Error collecting fees: " + error.message);
                }
            }

            async function withdrawPlatformFees() {
                try {
                    if (!signer) {
                        throw new Error("Please connect your wallet first");
                    }

                    console.log("Withdrawing platform fees...");
                    const tx = await CONTRACTWithSigner.withdrawPlatformFees();
                    await tx.wait();

                    console.log("âœ… Platform fees withdrawn!");
                    alert("Platform fees withdrawn successfully!");

                    // Refresh the display
                    await checkPlatformFees();

                } catch (error) {
                    console.error("Error withdrawing platform fees:", error);
                    alert("Error withdrawing platform fees: " + error.message);
                }
            }

            // Enhanced loadUserTokens with anti-sniper status
            async function loadUserTokensEnhanced(loadMore = false) {
                const list = document.getElementById('myTokensList');
                if (!list) return;
                if (!userAddress) {
                    list.textContent = 'Connect wallet to load your tokens...';
                    return;
                }

                if (!loadMore) userTokensPage = 0;

                try {
                    if (!loadMore) list.textContent = 'Loading your tokens...';
                    console.log('[Dashboard] Loading user tokens with anti-sniper info for', userAddress, 'page', userTokensPage);
                    const allTokens = await getUserTokens(userAddress);
                    console.log('[Dashboard] Total tokens:', allTokens.length);

                    let fees = null;
                    if (capability.creatorFees) {
                        try {
                            console.log('ðŸ’° Fetching creator fees for:', userAddress);
                            fees = await CONTRACT.getCreatorFees(userAddress);
                            const feeAmount = ethers.utils.formatEther(fees);
                            console.log('ðŸ’° Creator fees found:', feeAmount, 'ETH');
                        } catch (e) {
                            if (!capability.suppressedCreatorFeeWarn) {
                                console.warn('[Dashboard] Disabling creator aggregate fee probe after revert.');
                                capability.suppressedCreatorFeeWarn = true;
                            }
                            capability.creatorFees = false;
                            fees = null;
                        }
                    }

                    // Check for accumulated token balances
                    let tokenBalance = null;
                    try {
                        tokenBalance = await CONTRACT.getCreatorTokenBalance(userAddress);
                    } catch (e) {
                        console.log('Could not check token balance:', e.message);
                    }

                    const wd = document.getElementById('withdrawableCreatorFees');
                    if (wd) wd.textContent = fees ? fmt(fees) : '0.000000';
                    const withdrawBtn = document.getElementById('withdrawMyFeesBtn');
                    if (withdrawBtn) withdrawBtn.disabled = !fees || fees.eq(0);
                    const collectBtn = document.getElementById('collectMyFeesBtn');
                    if (collectBtn) collectBtn.disabled = allTokens.length === 0;

                    if (allTokens.length === 0) {
                        list.textContent = 'You have not launched any tokens yet.';
                        return;
                    }

                    // Pagination logic
                    const startIdx = userTokensPage * TOKENS_PER_PAGE;
                    const endIdx = startIdx + TOKENS_PER_PAGE;
                    const tokens = allTokens.slice(startIdx, endIdx);
                    const hasMore = endIdx < allTokens.length;

                    // Generate table rows with anti-sniper status
                    let tableRows = '';
                    for (const t of tokens) {
                        let raw = undefined;
                        if (t.totalFeesETH !== undefined) raw = t.totalFeesETH;
                        if (!raw && Array.isArray(t)) {
                            if (t.length > 9) raw = t[9];
                            else if (t.length > 7) raw = t[7];
                        }
                        const feeETH = fees ? sanitizeFee(raw, fees) : '0.000000';
                        const feeETHNum = parseFloat(feeETH.replace(/ ETH.*$/, ''));
                        const feeUSD = feeETHNum * currentETHPrice;
                        const fee = feeETHNum.toFixed(6) + ' ETH ($' + feeUSD.toFixed(2) + ')';
                        const name = t.name || t[2];
                        const tokenId = t.tokenId || t[4];
                        const tokenAddress = t.tokenAddress || t[0];

                        // Check anti-sniper status
                        let antiSniperStatus = 'Checking...';
                        try {
                            const devStatus = await checkDevBuyWindow(tokenAddress);
                            if (devStatus.inWindow) {
                                const minutes = Math.floor(devStatus.remainingTime / 60);
                                const seconds = devStatus.remainingTime % 60;
                                antiSniperStatus = `<span style="color:orange;">ðŸ›¡ï¸ Dev Window: ${minutes}:${seconds.toString().padStart(2, '0')}</span>`;
                            } else {
                                antiSniperStatus = '<span style="color:green;">ðŸŒ Public Trading</span>';
                            }
                        } catch {
                            antiSniperStatus = '<span style="color:gray;">â“ Unknown</span>';
                        }

                        // Check LP NFT status
                        let lpStatus = 'Checking...';
                        try {
                            const nfpm = new ethers.Contract(POSITION_MANAGER_ADDRESS, ["function ownerOf(uint256) view returns (address)"], provider);
                            const ownerAddr = await nfpm.ownerOf(tokenId);
                            const factoryAddr = TOKEN_FACTORY_ADDRESS.toLowerCase();

                            if (ownerAddr.toLowerCase() === factoryAddr) {
                                lpStatus = '<span style="color:green;">ðŸ”’ Locked</span>';
                            } else if (ownerAddr.toLowerCase() === userAddress.toLowerCase()) {
                                lpStatus = '<span style="color:red;">âš ï¸ In Wallet</span>';
                            } else {
                                lpStatus = '<span style="color:orange;">ðŸ‘¤ Other</span>';
                            }
                        } catch {
                            lpStatus = '<span style="color:gray;">â“ Unknown</span>';
                        }

                        tableRows += `<tr><td>${name}</td><td><a href="https://basescan.org/token/${tokenAddress}" target="_blank" style="color:#667eea;text-decoration:none;">${tokenAddress.slice(0, 10)}...${tokenAddress.slice(-8)}</a></td><td style="text-align:right;font-weight:600;">${fee}</td><td style="text-align:center;">${antiSniperStatus}</td><td style="text-align:center;">${lpStatus}</td></tr>`;
                    }

                    if (!loadMore) {
                        // Initial load - create full table
                        let html = '<div class="table-container"><table>';
                        html += '<thead><tr><th>Name</th><th>Token Address</th><th>Fees (ETH)</th><th>Trading Status</th><th>LP Status</th></tr></thead>';
                        html += '<tbody>' + tableRows + '</tbody>';
                        html += '</table></div>';

                        // Add token balance info if any
                        if (tokenBalance && tokenBalance.gt(0)) {
                            html += `<div style="margin-top:12px;padding:8px;background:#e3f2fd;border-radius:6px;font-size:0.8rem;">
                            Accumulated Token Fees: ${ethers.utils.formatEther(tokenBalance)} tokens
                            <button onclick="batchSwapTokens()" style="margin-left:8px;padding:2px 6px;font-size:0.7rem;background:#2196f3;color:white;border:none;border-radius:3px;cursor:pointer;">Swap to ETH</button>
                        </div>`;
                        }

                        if (hasMore) {
                            html += `<div style="display:flex;justify-content:center;margin-top:12px;"><button onclick="loadMoreUserTokens()" class="btn btn-secondary">Load More (${allTokens.length - endIdx} remaining)</button></div>`;
                        }

                        list.innerHTML = html;
                    } else {
                        // Load more - append rows to existing table
                        const tbody = list.querySelector('table tbody');
                        if (tbody) {
                            tbody.insertAdjacentHTML('beforeend', tableRows);
                        }

                        // Update load more button
                        const loadMoreBtn = list.querySelector('button');
                        if (loadMoreBtn) {
                            if (hasMore) {
                                loadMoreBtn.textContent = `Load More (${allTokens.length - endIdx} remaining)`;
                            } else {
                                loadMoreBtn.remove();
                            }
                        }
                    }

                    if (!loadMore) {
                        userTokensPage = 1; // Set to 1 after first load
                    } else {
                        userTokensPage++; // Increment only for load more
                    }
                } catch (err) {
                    list.textContent = 'Failed to load';
                    console.error(err);
                }
            }

            // Override the original loadUserTokens with the enhanced version
            loadUserTokens = loadUserTokensEnhanced;
        </script>

        <!--======= HERO SECTION ===========
        ====================================
        =================================-->

        <section class="utility-hero">
            <div class="utility-hero__bg" aria-hidden="true"></div>
            <div class="utility-hero-content">
                <h1>BASE STAKING</h1>
                <p>Advanced DeFi Staking Platform - Create, Deploy, and Manage Staking Contracts on Base Network</p>
            </div>
        </section>


        <!-- JavaScript for Parallax effect-->

        <script>
            (function () {
                const bg = document.querySelector('.utility-hero__bg');
                if (!bg) return;

                const speed = 0.6; // lower = subtler effect
                const reduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

                if (reduce) return; // skip for reduced motion users

                let ticking = false;

                function onScroll() {
                    if (!ticking) {
                        requestAnimationFrame(() => {
                            const y = window.scrollY * speed;
                            bg.style.transform = `translateY(${y}px)`;
                            ticking = false;
                        });
                        ticking = true;
                    }
                }

                window.addEventListener('scroll', onScroll, { passive: true });
                onScroll();
            })();
        </script>

        <!-- End page wrapper -->

        <!--========== FOOTER ==============
        ====================================
        =================================-->

        <footer>
            <div class="footer-section">
                <p class="wild-west-footer">WILDWEST LAUNCHPAD</p>
                <div class="footer-socials">
                    <a href="https://t.me/wildwestlaunchpad" target="_blank" rel="noopener">
                        <img src="../images/icons/icons8-telegram-app-240_WHITE.png" alt="Telegram" class="nav-icon">
                    </a>
                    <a href="https://x.com/WILDWESTLP?t=wmcDfvCKnkAaLCtJbmAxgA" target="_blank" rel="noopener">
                        <img src="../images/icons/icons8-twitterx-240_WHITE.png" alt="Twitter/X" class="nav-icon">
                    </a>
                    <a href="https://dexscreener.com/base/0x8129609e5303910464fce3022a809fa44455fe9a" target="_blank"
                        rel="noopener">
                        <img src="../images/icons/661375b92a7e161501f4b5e5_dexscreener.322a5a2d_WHITE.png"
                            alt="DEXScreener" class="nav-icon">
                    </a>
                </div>
                <p class="footer-wildw">$WILDW TOKEN (BASE)</p>
                <span class="footer-address" id="contract-address">0x8129609E5303910464FCe3022a809fA44455Fe9A</span>



                <p class="footer-url">&copy; 2025 Wild West Launchpad. All rights reserved.</p>
            </div>
        </footer>
    </div>
    <div class="background-effects"></div>
    
    <div class="container">
        <a href="../index.html" class="back-btn">
            <span>Back to Main</span>
        </a>
        <div class="hero-section">
            <h1 class="hero-title">BASE STAKING FACTORY</h1>
            <p class="hero-subtitle">Advanced DeFi Staking Platform - Create, Deploy, and Manage Staking Contracts on Base Network</p>
        </div>
        
        <div class="header main-card">
            <div class="wallet-section">
                <button id="connectWallet" class="wallet-btn">Connect Wallet</button>
                <div id="walletInfo" class="wallet-info" style="display: none;"></div>
            </div>
        </div>

        <div class="stats-grid main-card" id="statsGrid" style="display: none;">
            <div class="stat-card">
                <div class="stat-value" id="totalContracts">0</div>
                <div class="stat-label">Total Contracts</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalStaked">0</div>
                <div class="stat-label">Total Tokens Staked</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="userContracts">0</div>
                <div class="stat-label">Your Contracts</div>
            </div>
        </div>

        <div class="section">
            <h2>Deploy New Staking Contract</h2>
            <form id="deployForm">
                <div class="form-grid">
                    <div class="form-group">
                        <label>Staking Token Address</label>
                        <input type="text" id="stakingToken" class="form-input" placeholder="0x0000... (or 0x0 for ETH)" required>
                    </div>
                    <div class="form-group">
                        <label>Reward Token Address</label>
                        <input type="text" id="rewardToken" class="form-input" placeholder="0x0000... (or 0x0 for ETH)" required>
                    </div>
                    <div class="form-group">
                        <label>Early Withdrawal Fee Period (days)</label>
                        <input type="number" id="lockPeriod" class="form-input" placeholder="30" min="0" required>
                    </div>
                    <div class="form-group">
                        <label>Early Withdrawal Fee (%)</label>
                        <input type="number" id="earlyFee" class="form-input" placeholder="5" min="0" max="50" step="0.1" required>
                    </div>
                    <div class="form-group">
                        <label>Annual Percentage Yield (%)</label>
                        <input type="number" id="apy" class="form-input" placeholder="12.5" min="0.1" max="1000" step="0.1" required>
                    </div>
                    <div class="form-group">
                        <label>Minimum Stake Amount</label>
                        <input type="number" id="minStake" class="form-input" placeholder="0.01" min="0" step="0.000001" required>
                    </div>
                    <div class="form-group" style="grid-column: 1 / -1;">
                        <label>Contract Name</label>
                        <input type="text" id="contractName" class="form-input" placeholder="My Staking Pool" required>
                    </div>
                </div>
                <div style="text-align: center; margin-top: var(--spacing-md);">
                    <button type="submit" class="btn">Deploy Contract</button>
                </div>
            </form>
            <div id="deployStatus"></div>
        </div>

        <div class="section">
            <h2>Staking Contracts Directory</h2>
            
            <!-- Search and Filter Controls -->
            <div class="search-filter-container">
                <div class="search-box">
                    <input type="text" id="searchInput" class="search-input" placeholder="Search by contract name, token symbol, or address..." />
                    <button class="search-btn" onclick="searchContracts()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                    </button>
                </div>
                
                <div class="results-info">
                    <span id="resultsCount">Loading contracts...</span>
                    <button class="refresh-btn" onclick="refreshDirectory()" title="Refresh Directory">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="23 4 23 10 17 10"></polyline>
                            <polyline points="1 20 1 14 7 14"></polyline>
                            <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>
                        </svg>
                    </button>
                </div>
            </div>
            
            <div id="contractsContainer">
                <div class="loading">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Staking Modal -->
    <div id="stakingModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal()">&times;</span>
            <h2 id="modalTitle">Staking Contract Details</h2>
            <div id="modalContent"></div>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            FACTORY_ADDRESS: "0xCA79ffE059c460b206a0f133C83d5136c754cB97",
            QUICKNODE_URL: "https://responsive-omniscient-model.base-mainnet.quiknode.pro/aa86b92100862c55985ff1d322a9ff07d9ab236f/",
            BASESCAN_API_KEY: "TZJQES8ZA41X17W1NIDIKHBVSMHBDID9RU",
            CHAIN_ID: 8453, // Base mainnet
            NETWORK_NAME: "Base Mainnet"
        };

        // Factory ABI
        const FACTORY_ABI = [
            {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"contractAddress","type":"address"},{"indexed":true,"internalType":"address","name":"creator","type":"address"},{"indexed":false,"internalType":"string","name":"name","type":"string"},{"indexed":false,"internalType":"address","name":"stakingToken","type":"address"},{"indexed":false,"internalType":"address","name":"rewardToken","type":"address"}],"name":"StakingContractDeployed","type":"event"},
            {"inputs":[{"internalType":"address","name":"_stakingToken","type":"address"},{"internalType":"address","name":"_rewardToken","type":"address"},{"internalType":"uint256","name":"_lockPeriod","type":"uint256"},{"internalType":"uint256","name":"_earlyFee","type":"uint256"},{"internalType":"uint256","name":"_apy","type":"uint256"},{"internalType":"uint256","name":"_minStake","type":"uint256"},{"internalType":"string","name":"_name","type":"string"}],"name":"deployStakingContract","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"deployedContracts","outputs":[{"internalType":"address","name":"contractAddress","type":"address"},{"internalType":"address","name":"creator","type":"address"},{"internalType":"address","name":"stakingToken","type":"address"},{"internalType":"address","name":"rewardToken","type":"address"},{"internalType":"string","name":"name","type":"string"},{"internalType":"uint256","name":"lockPeriod","type":"uint256"},{"internalType":"uint256","name":"earlyFee","type":"uint256"},{"internalType":"uint256","name":"apy","type":"uint256"},{"internalType":"uint256","name":"minStake","type":"uint256"},{"internalType":"uint256","name":"createdAt","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"getAllContracts","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getContractInfo","outputs":[{"components":[{"internalType":"address","name":"contractAddress","type":"address"},{"internalType":"address","name":"creator","type":"address"},{"internalType":"address","name":"stakingToken","type":"address"},{"internalType":"address","name":"rewardToken","type":"address"},{"internalType":"string","name":"name","type":"string"},{"internalType":"uint256","name":"lockPeriod","type":"uint256"},{"internalType":"uint256","name":"earlyFee","type":"uint256"},{"internalType":"uint256","name":"apy","type":"uint256"},{"internalType":"uint256","name":"minStake","type":"uint256"},{"internalType":"uint256","name":"createdAt","type":"uint256"}],"internalType":"struct StakingFactory.ContractInfo","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"getContractsByToken","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"getDeployedContractsCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getUserContracts","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isStakingContract","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"userContracts","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}
        ];

        // Staking Contract ABI
        const STAKING_ABI = [
            {"inputs":[{"internalType":"address","name":"_stakingToken","type":"address"},{"internalType":"address","name":"_rewardToken","type":"address"},{"internalType":"uint256","name":"_lockPeriod","type":"uint256"},{"internalType":"uint256","name":"_earlyFee","type":"uint256"},{"internalType":"uint256","name":"_apy","type":"uint256"},{"internalType":"uint256","name":"_minStake","type":"uint256"},{"internalType":"string","name":"_name","type":"string"}],"stateMutability":"nonpayable","type":"constructor"},
            {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},
            {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"rewards","type":"uint256"}],"name":"RewardsClaimed","type":"event"},
            {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"Staked","type":"event"},
            {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"fee","type":"uint256"}],"name":"Withdrawn","type":"event"},
            {"inputs":[],"name":"apy","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"canWithdrawWithoutFee","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"claimRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[],"name":"contractName","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"depositRewards","outputs":[],"stateMutability":"payable","type":"function"},
            {"inputs":[],"name":"earlyFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"emergencyWithdrawEnabled","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"enableEmergencyWithdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[],"name":"getBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getPendingRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getStakedAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getStakeTimestamp","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"lockPeriod","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"minStake","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[],"name":"rewardToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"stake","outputs":[],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"stakes","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"uint256","name":"lastClaimTime","type":"uint256"},{"internalType":"uint256","name":"rewards","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"stakingToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"totalRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"totalStaked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdrawExcess","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"stateMutability":"payable","type":"receive"}
        ];

        // Global variables
        let provider, signer, factoryContract, userAddress, currentNetwork;
        let tokenCache = {}; // Cache for ERC20 token information
        
        // Hardcoded blacklist - hide all contracts deployed before this timestamp
        // Set to just before your latest contract to show your real contracts
        const BLACKLIST_BEFORE_TIMESTAMP = 1757299900; // September 7, 2025 9:51:40 PM - show contracts after this time
        
        // Additional hardcoded blacklisted contract addresses (specific test contracts to hide)
        const HARDCODED_BLACKLIST = new Set([
            // These will be populated with current test contract addresses
            // Add specific contract addresses here as they are identified
        ]);

        // Function to get all current contracts and add them to blacklist (for debugging)
        async function getAllCurrentContractsForBlacklist() {
            try {
                if (!factoryContract) return;
                const count = await factoryContract.getDeployedContractsCount();
                console.log(`Found ${count.toNumber()} total contracts`);
                
                const addresses = [];
                for (let i = 0; i < count.toNumber(); i++) {
                    const info = await factoryContract.getContractInfo(i);
                    addresses.push(info.contractAddress.toLowerCase());
                    console.log(`Contract ${i}: ${info.contractAddress}, created: ${info.createdAt ? info.createdAt.toNumber() : 'unknown'}`);
                }
                
                console.log('All contract addresses to blacklist:', addresses);
                return addresses;
            } catch (error) {
                console.error('Error getting contracts for blacklist:', error);
                return [];
            }
        }

        // Check if contract should be hidden (deployed before cutoff date or specifically blacklisted)
        function isBlacklisted(contractInfo) {
            // Check if contract is in hardcoded blacklist
            if (HARDCODED_BLACKLIST.has(contractInfo.contractAddress.toLowerCase())) {
                return true;
            }
            
            // Check if contract was deployed before the blacklist timestamp
            const deploymentTime = contractInfo.createdAt ? contractInfo.createdAt.toNumber() : 0;
            return deploymentTime < BLACKLIST_BEFORE_TIMESTAMP;
        }

        // ERC20 Token ABI for getting symbol and decimals
        const ERC20_ABI = [
            "function symbol() view returns (string)",
            "function name() view returns (string)",
            "function decimals() view returns (uint8)",
            "function balanceOf(address) view returns (uint256)"
        ];

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
            // Only load contracts after wallet connection, not on page load
            // loadContractsDirectory() and updateStats() will be called after wallet connects
        });

        // Initialize the application
        async function initializeApp() {
            // Set up event listeners
            document.getElementById('connectWallet').addEventListener('click', connectWallet);
            document.getElementById('deployForm').addEventListener('submit', deployContract);

            // Check if wallet is already connected
            if (window.ethereum && window.ethereum.selectedAddress) {
                await connectWallet();
            }

            // Set up provider for read-only operations
            provider = new ethers.providers.JsonRpcProvider(CONFIG.QUICKNODE_URL);
            factoryContract = new ethers.Contract(CONFIG.FACTORY_ADDRESS, FACTORY_ABI, provider);
        }

        // Utility function to get ERC20 token info
        async function getTokenInfo(tokenAddress) {
            if (tokenAddress === ethers.constants.AddressZero) {
                return { symbol: 'ETH', name: 'Ethereum', decimals: 18 };
            }

            if (tokenCache[tokenAddress]) {
                return tokenCache[tokenAddress];
            }

            try {
                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                const [symbol, name, decimals] = await Promise.all([
                    tokenContract.symbol(),
                    tokenContract.name(),
                    tokenContract.decimals()
                ]);

                const tokenInfo = { symbol, name, decimals };
                tokenCache[tokenAddress] = tokenInfo;
                return tokenInfo;
            } catch (error) {
                console.warn(`Could not fetch token info for ${tokenAddress}:`, error);
                return { symbol: 'UNKNOWN', name: 'Unknown Token', decimals: 18 };
            }
        }

        // Utility function to copy text to clipboard
        async function copyToClipboard(text, element) {
            try {
                await navigator.clipboard.writeText(text);
                const originalText = element.textContent;
                element.textContent = 'Copied!';
                element.style.color = 'var(--success-color)';
                setTimeout(() => {
                    element.textContent = originalText;
                    element.style.color = 'var(--accent-color)';
                }, 2000);
            } catch (error) {
                console.error('Failed to copy:', error);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showStatus('Copied to clipboard', 'success');
            }
        }

        // Format date without time
        function formatDateOnly(timestamp) {
            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
        }

        // Connect wallet function
        async function connectWallet() {
            // Detect platform and available wallets before showing modal
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                showMobileWalletModal();
            } else {
                showDesktopWalletModal();
            }
        }

        // Show mobile wallet modal with app guidance
        function showMobileWalletModal() {
            const modal = document.getElementById('walletModal');
            const modalContent = modal.querySelector('.wallet-modal-content');
            
            // Check if we're already in a wallet browser
            const isInWalletBrowser = window.ethereum && (
                window.ethereum.isMetaMask || 
                window.ethereum.isCoinbaseWallet || 
                window.ethereum.isTrust ||
                window.ethereum.isRabby
            );
            
            if (isInWalletBrowser) {
                // User is already in a wallet browser, attempt direct connection
                closeWalletModal();
                const walletType = getWalletType();
                connectWithProvider(window.ethereum, walletType);
                return;
            }
            
            // User is NOT in a wallet browser, show guidance
            modalContent.innerHTML = `
                <div class="wallet-modal-header">
                    <h3>Connect Mobile Wallet</h3>
                    <button class="close-modal" onclick="closeWalletModal()">Ã—</button>
                </div>
                <div class="mobile-notice">
                    <strong>You need to open this page inside your wallet app's browser to connect.</strong>
                </div>
                <div class="mobile-instructions">
                    <h4>Step-by-step instructions:</h4>
                    <ol>
                        <li><strong>Copy this page URL:</strong><br><button onclick="copyCurrentUrl()" class="copy-url-btn">Copy URL</button></li>
                        <li><strong>Open your wallet app</strong> (choose from below)</li>
                        <li><strong>Find the Browser/DApp section</strong> in your wallet</li>
                        <li><strong>Paste the URL</strong> and navigate to this page</li>
                        <li><strong>The wallet will auto-connect</strong> when you're in the app browser</li>
                    </ol>
                </div>
                <div class="compatible-wallets">
                    <h4>Compatible Mobile Wallets:</h4>
                    <div class="wallet-list-info">
                        <div class="wallet-info-item">
                            <span class="wallet-name">MetaMask Mobile</span>
                            <span class="wallet-desc">Most popular Web3 wallet</span>
                        </div>
                        <div class="wallet-info-item">
                            <span class="wallet-name">Coinbase Wallet</span>
                            <span class="wallet-desc">Integrated with Coinbase exchange</span>
                        </div>
                        <div class="wallet-info-item">
                            <span class="wallet-name">Trust Wallet</span>
                            <span class="wallet-desc">Binance's official wallet</span>
                        </div>
                        <div class="wallet-info-item">
                            <span class="wallet-name">Rainbow Wallet</span>
                            <span class="wallet-desc">Ethereum-focused wallet</span>
                        </div>
                    </div>
                </div>
                <div class="mobile-footer">
                    <p><strong>Why can't I connect here?</strong><br>
                    Mobile browsers (Safari, Chrome) don't have wallet extensions. You need to use your wallet app's built-in browser to connect securely.</p>
                </div>
            `;
            
            modal.style.display = 'flex';
        }

        // Detect which wallet type is currently active
        function getWalletType() {
            if (window.ethereum.isMetaMask) return 'metamask';
            if (window.ethereum.isCoinbaseWallet) return 'coinbase';
            if (window.ethereum.isTrust) return 'trust';
            if (window.ethereum.isRabby) return 'rabby';
            return 'generic';
        }

        // Copy current page URL to clipboard
        function copyCurrentUrl() {
            const currentUrl = window.location.href;
            
            navigator.clipboard.writeText(currentUrl).then(() => {
                showStatus('URL copied to clipboard!', 'success');
            }).catch(() => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = currentUrl;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showStatus('URL copied to clipboard!', 'success');
            });
        }

        // Legacy copy function (kept for compatibility)
        function copyToClipboard(text) {
            copyCurrentUrl();
        }

        // Show desktop wallet modal with detected extensions
        function showDesktopWalletModal() {
            const availableWallets = detectWalletExtensions();
            const modal = document.getElementById('walletModal');
            const modalContent = modal.querySelector('.wallet-modal-content');
            
            let walletOptionsHtml = '';
            
            if (availableWallets.length === 0) {
                walletOptionsHtml = `
                    <div class="no-wallets-notice">
                        <p>No wallet extensions detected. Please install a wallet extension:</p>
                    </div>
                    <div class="wallet-options">
                        <button class="wallet-option install-wallet" onclick="installWallet('metamask')">
                            <span class="wallet-name">Install MetaMask</span>
                            <span class="wallet-desc">Most popular Web3 wallet</span>
                        </button>
                        <button class="wallet-option install-wallet" onclick="installWallet('coinbase')">
                            <span class="wallet-name">Install Coinbase Wallet</span>
                            <span class="wallet-desc">Extension by Coinbase</span>
                        </button>
                        <button class="wallet-option install-wallet" onclick="installWallet('rabby')">
                            <span class="wallet-name">Install Rabby Wallet</span>
                            <span class="wallet-desc">Multi-chain wallet extension</span>
                        </button>
                    </div>
                `;
            } else {
                walletOptionsHtml = `
                    <div class="available-wallets-notice">
                        <p>Available wallet extensions:</p>
                    </div>
                    <div class="wallet-options">
                        ${availableWallets.map(wallet => `
                            <button class="wallet-option" onclick="connectDesktopWallet('${wallet.id}')">
                                <span class="wallet-name">${wallet.name}</span>
                                <span class="wallet-desc">Connect with ${wallet.name}</span>
                            </button>
                        `).join('')}
                    </div>
                `;
            }
            
            modalContent.innerHTML = `
                <div class="wallet-modal-header">
                    <h3>Connect Desktop Wallet</h3>
                    <button class="close-modal" onclick="closeWalletModal()">Ã—</button>
                </div>
                ${walletOptionsHtml}
            `;
            
            modal.style.display = 'flex';
        }

        // Detect available wallet extensions
        function detectWalletExtensions() {
            const wallets = [];
            
            // Check for MetaMask
            if (window.ethereum && window.ethereum.isMetaMask) {
                wallets.push({ id: 'metamask', name: 'MetaMask', provider: window.ethereum });
            }
            
            // Check for Coinbase Wallet
            if (window.ethereum && window.ethereum.isCoinbaseWallet) {
                wallets.push({ id: 'coinbase', name: 'Coinbase Wallet', provider: window.ethereum });
            }
            
            // Check for Rabby
            if (window.ethereum && window.ethereum.isRabby) {
                wallets.push({ id: 'rabby', name: 'Rabby Wallet', provider: window.ethereum });
            }
            
            // Check for Trust Wallet (desktop extension)
            if (window.ethereum && window.ethereum.isTrust) {
                wallets.push({ id: 'trust', name: 'Trust Wallet', provider: window.ethereum });
            }
            
            // Generic ethereum provider (if no specific wallet detected but ethereum exists)
            if (window.ethereum && wallets.length === 0) {
                wallets.push({ id: 'generic', name: 'Web3 Wallet', provider: window.ethereum });
            }
            
            return wallets;
        }

        // Close wallet modal
        function closeWalletModal() {
            document.getElementById('walletModal').style.display = 'none';
        }

        // Connect desktop wallet
        async function connectDesktopWallet(walletId) {
            const wallets = detectWalletExtensions();
            const selectedWallet = wallets.find(w => w.id === walletId);
            
            if (!selectedWallet) {
                showStatus('Selected wallet not found. Please refresh and try again.', 'error');
                return;
            }
            
            await connectWithProvider(selectedWallet.provider, walletId);
        }

        // Install wallet extension
        function installWallet(walletType) {
            const walletLinks = {
                'metamask': 'https://metamask.io/download/',
                'coinbase': 'https://www.coinbase.com/wallet/downloads',
                'rabby': 'https://rabby.io/',
                'trust': 'https://trustwallet.com/browser-extension'
            };
            
            if (walletLinks[walletType]) {
                window.open(walletLinks[walletType], '_blank');
                closeWalletModal();
            }
        }

        // Connect with provider (unified connection logic)
        async function connectWithProvider(provider, walletType) {
            try {
                closeWalletModal();
                
                if (!provider) {
                    showStatus('Wallet provider not available', 'error');
                    return;
                }

                // Request account access
                const accounts = await provider.request({ 
                    method: 'eth_requestAccounts' 
                });

                // Check if we're on Base network
                const chainId = await provider.request({ 
                    method: 'eth_chainId' 
                });

                if (parseInt(chainId, 16) !== CONFIG.CHAIN_ID) {
                    try {
                        await provider.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: `0x${CONFIG.CHAIN_ID.toString(16)}` }],
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            // Network not added, add it
                            await provider.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: `0x${CONFIG.CHAIN_ID.toString(16)}`,
                                    chainName: CONFIG.NETWORK_NAME,
                                    nativeCurrency: {
                                        name: 'ETH',
                                        symbol: 'ETH',
                                        decimals: 18,
                                    },
                                    rpcUrls: [CONFIG.QUICKNODE_URL],
                                    blockExplorerUrls: ['https://basescan.org/'],
                                }],
                            });
                        }
                    }
                }

                // Create ethers provider and signer
                window.ethereum = provider; // Set global ethereum for compatibility
                provider = new ethers.providers.Web3Provider(provider);
                signer = provider.getSigner();
                userAddress = await signer.getAddress();
                currentNetwork = await provider.getNetwork();

                factoryContract = new ethers.Contract(CONFIG.FACTORY_ADDRESS, FACTORY_ABI, signer);

                // Update UI
                document.getElementById('connectWallet').textContent = 'Connected';
                document.getElementById('connectWallet').disabled = true;
                document.getElementById('walletInfo').style.display = 'block';
                document.getElementById('walletInfo').innerHTML = `
                    <strong>Address:</strong> ${userAddress.substring(0, 6)}...${userAddress.substring(38)}<br>
                    <strong>Network:</strong> ${CONFIG.NETWORK_NAME}<br>
                    <strong>Wallet:</strong> ${walletType.charAt(0).toUpperCase() + walletType.slice(1)}
                `;
                document.getElementById('statsGrid').style.display = 'grid';

                showStatus(`Successfully connected with ${walletType.charAt(0).toUpperCase() + walletType.slice(1)}`, 'success');
                updateStats();
                loadContractsDirectory();

            } catch (error) {
                console.error('Error connecting wallet:', error);
                if (error.code === 4001) {
                    showStatus('Connection rejected by user', 'warning');
                } else {
                    showStatus('Failed to connect wallet: ' + error.message, 'error');
                }
            }
        }

        // Deploy contract function
        async function deployContract(event) {
            event.preventDefault();
            
            if (!signer) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            try {
                // Get and validate all form inputs with strict validation
                const stakingTokenRaw = document.getElementById('stakingToken').value.trim();
                const rewardTokenRaw = document.getElementById('rewardToken').value.trim();
                const lockPeriodRaw = document.getElementById('lockPeriod').value.trim();
                const earlyFeeRaw = document.getElementById('earlyFee').value.trim();
                const apyRaw = document.getElementById('apy').value.trim();
                const minStakeRaw = document.getElementById('minStake').value.trim();
                const contractName = document.getElementById('contractName').value.trim();

                // Validate required fields
                if (!stakingTokenRaw || !rewardTokenRaw || !lockPeriodRaw || !earlyFeeRaw || !apyRaw || !minStakeRaw || !contractName) {
                    showStatus('All fields are required', 'error');
                    return;
                }

                // Parse and validate numeric inputs
                const lockPeriodDays = parseInt(lockPeriodRaw, 10);
                if (isNaN(lockPeriodDays) || lockPeriodDays < 0 || lockPeriodDays > 3650) {
                    showStatus('Early withdrawal fee period must be between 0 and 3650 days', 'error');
                    return;
                }
                
                // Convert days to seconds for blockchain storage
                const lockPeriod = lockPeriodDays * 86400;

                const earlyFeePercent = parseFloat(earlyFeeRaw);
                if (isNaN(earlyFeePercent) || earlyFeePercent < 0 || earlyFeePercent > 50) {
                    showStatus('Early fee must be between 0% and 50%', 'error');
                    return;
                }
                const earlyFee = Math.round(earlyFeePercent * 100); // Convert to basis points (5% = 500)

                const apyPercent = parseFloat(apyRaw);
                if (isNaN(apyPercent) || apyPercent < 0.1 || apyPercent > 1000) {
                    showStatus('APY must be between 0.1% and 1000%', 'error');
                    return;
                }
                const apy = Math.round(apyPercent * 100); // Convert to basis points (10% = 1000)

                const minStakeFloat = parseFloat(minStakeRaw);
                if (isNaN(minStakeFloat) || minStakeFloat <= 0) {
                    showStatus('Minimum stake must be greater than 0', 'error');
                    return;
                }
                const minStake = ethers.utils.parseEther(minStakeRaw);

                // Validate token addresses
                const stakingToken = stakingTokenRaw === '0x0' ? ethers.constants.AddressZero : stakingTokenRaw;
                const rewardToken = rewardTokenRaw === '0x0' ? ethers.constants.AddressZero : rewardTokenRaw;

                if (stakingToken !== ethers.constants.AddressZero && !ethers.utils.isAddress(stakingToken)) {
                    showStatus('Invalid staking token address', 'error');
                    return;
                }
                if (rewardToken !== ethers.constants.AddressZero && !ethers.utils.isAddress(rewardToken)) {
                    showStatus('Invalid reward token address', 'error');
                    return;
                }

                // Validate contract name
                if (contractName.length < 1 || contractName.length > 50) {
                    showStatus('Contract name must be between 1 and 50 characters', 'error');
                    return;
                }

                // Display exact values that will be sent to blockchain for confirmation
                const confirmationMessage = `
                    Please confirm deployment with these EXACT parameters:
                    â€¢ Staking Token: ${stakingToken}
                    â€¢ Reward Token: ${rewardToken}
                    â€¢ Early Withdrawal Fee Period: ${lockPeriodDays} days (${lockPeriod} seconds)
                    â€¢ Early Withdrawal Fee: ${earlyFeePercent}% (${earlyFee} basis points)
                    â€¢ APY: ${apyPercent}% (${apy} basis points)
                    â€¢ Min Stake: ${minStakeRaw} (${ethers.utils.formatEther(minStake)} tokens)
                    â€¢ Name: "${contractName}"
                `;
                
                if (!confirm(confirmationMessage)) {
                    showStatus('Deployment cancelled by user', 'warning');
                    return;
                }

                showStatus('Deploying contract... Please confirm the transaction', 'warning');

                // Deploy with validated parameters
                const tx = await factoryContract.deployStakingContract(
                    stakingToken,
                    rewardToken,
                    lockPeriod,
                    earlyFee,
                    apy,
                    minStake,
                    contractName
                );

                showStatus('Transaction submitted. Waiting for confirmation...', 'warning');

                const receipt = await tx.wait();
                
                // Get the deployed contract address from the event
                const deployEvent = receipt.events.find(e => e.event === 'StakingContractDeployed');
                if (!deployEvent) {
                    throw new Error('Contract deployment event not found in transaction receipt');
                }
                const newContractAddress = deployEvent.args.contractAddress;

                showStatus(`Contract deployed successfully! Address: ${newContractAddress}`, 'success');

                // Add link to view on Basescan
                setTimeout(() => {
                    showStatus(`Contract deployed! <a href="https://basescan.org/address/${newContractAddress}" target="_blank" style="color: var(--accent-color);">View on Basescan</a>`, 'success');
                }, 1000);

                // Reset form
                document.getElementById('deployForm').reset();

                // Store deployment parameters for verification
                const deploymentData = {
                    stakingToken,
                    rewardToken,
                    lockPeriod,
                    earlyFee: earlyFeePercent, // Store original percentage for verification
                    apy: apyPercent, // Store original percentage for verification
                    minStake: minStakeRaw,
                    contractName
                };

                // Verify contract on Basescan with exact parameters
                setTimeout(() => {
                    verifyContract(newContractAddress, deploymentData);
                }, 10000); // Wait 10 seconds for contract to be indexed

                // Refresh stats and contracts
                updateStats();
                loadContractsDirectory();

            } catch (error) {
                console.error('Error deploying contract:', error);
                showStatus('âŒ Failed to deploy contract: ' + error.message, 'error');
            }
        }

        // Load contracts directory
        async function loadContractsDirectory() {
            try {
                const contractsContainer = document.getElementById('contractsContainer');
                contractsContainer.innerHTML = '<div class="loading"><div class="spinner"></div></div>';

                // Check if factoryContract is initialized
                if (!factoryContract) {
                    contractsContainer.innerHTML = '<p style="text-align: center; color: var(--secondary-text);">Please connect your wallet to view contracts.</p>';
                    return;
                }

                const count = await factoryContract.getDeployedContractsCount();
                console.log(`ðŸ“Š Total contracts in factory: ${count.toNumber()}`);
                
                if (count.eq(0)) {
                    contractsContainer.innerHTML = '<p style="text-align: center; color: var(--secondary-text);">No contracts deployed yet.</p>';
                    return;
                }

                const contracts = [];
                for (let i = 0; i < count.toNumber(); i++) {
                    const info = await factoryContract.getContractInfo(i);
                    const deploymentTime = info.createdAt ? info.createdAt.toNumber() : 0;
                    const isBlacklisted = deploymentTime < BLACKLIST_BEFORE_TIMESTAMP;
                    
                    // Only include contracts that are not blacklisted
                    if (!isBlacklisted) {
                        contracts.push(info);
                        console.log(`âœ… Contract ${i} (${info.name}) added to display`);
                    }
                }

                console.log(`ðŸ“‹ Contracts to display: ${contracts.length}`);

                // Check if all contracts are blacklisted
                if (contracts.length === 0) {
                    contractsContainer.innerHTML = '<p style="text-align: center; color: var(--secondary-text);">No active contracts to display.</p>';
                    return;
                }

                // Sort contracts by creation date (newest first)
                contracts.sort((a, b) => b.createdAt.toNumber() - a.createdAt.toNumber());

                let html = '<div class="contracts-grid">';
                for (const contract of contracts) {
                    const cardHtml = await createContractCard(contract); // Now async
                    html += cardHtml;
                }
                html += '</div>';

                contractsContainer.innerHTML = html;

            } catch (error) {
                console.error('Error loading contracts:', error);
                const contractsContainer = document.getElementById('contractsContainer');
                if (!factoryContract) {
                    contractsContainer.innerHTML = '<p style="text-align: center; color: var(--warning-color);">Please connect your wallet to view contracts.</p>';
                } else {
                    contractsContainer.innerHTML = '<p style="color: var(--error-color);">Error loading contracts: ' + error.message + '</p>';
                }
            }
        }

        // Create contract card HTML with accurate data parsing and professional features
        async function createContractCard(contract) {
            // Get token information for professional display
            const stakingTokenInfo = await getTokenInfo(contract.stakingToken);
            const rewardTokenInfo = await getTokenInfo(contract.rewardToken);

            const stakingTokenDisplay = stakingTokenInfo.symbol === 'ETH' ? 'ETH' : 
                `${contract.stakingToken.substring(0, 6)}...${contract.stakingToken.substring(38)}`;
            const rewardTokenDisplay = rewardTokenInfo.symbol === 'ETH' ? 'ETH' : 
                `${contract.rewardToken.substring(0, 6)}...${contract.rewardToken.substring(38)}`;
            
            // Professional date formatting (date only)
            const createdDate = formatDateOnly(contract.createdAt.toNumber());
            
            // CRITICAL FIX: Check actual current owner, not just original creator
            let isOwner = false;
            let currentOwner = contract.creator; // Default fallback
            
            try {
                const stakingContract = new ethers.Contract(contract.contractAddress, STAKING_ABI, provider);
                currentOwner = await stakingContract.owner();
                isOwner = userAddress && currentOwner.toLowerCase() === userAddress.toLowerCase();
                
                console.log(`ðŸ” Ownership check for ${contract.name}:`, {
                    originalCreator: contract.creator,
                    currentOwner: currentOwner,
                    userAddress: userAddress,
                    isOwner: isOwner,
                    ownershipTransferred: currentOwner.toLowerCase() !== contract.creator.toLowerCase()
                });
            } catch (error) {
                console.warn(`Could not get current owner for ${contract.name}, falling back to creator check:`, error.message);
                isOwner = userAddress && contract.creator.toLowerCase() === userAddress.toLowerCase();
            }
            
            // CRITICAL FIX: Get lockPeriod directly from staking contract for accuracy
            let actualLockPeriod = contract.lockPeriod;
            try {
                const stakingContract = new ethers.Contract(contract.contractAddress, STAKING_ABI, provider);
                actualLockPeriod = await stakingContract.lockPeriod();
                console.log(`ðŸ” Contract ${contract.name}: Factory says ${contract.lockPeriod.toString()}s, actual contract says ${actualLockPeriod.toString()}s`);
            } catch (error) {
                console.warn(`Could not get actual lockPeriod for ${contract.name}, using factory data:`, error.message);
            }
            
            console.log('ðŸ‘¤ Admin Check:', {
                contractName: contract.name,
                contractCreator: contract.creator,
                userAddress: userAddress,
                isOwner: isOwner,
                creatorLower: contract.creator ? contract.creator.toLowerCase() : 'no creator',
                userLower: userAddress ? userAddress.toLowerCase() : 'no user'
            });

            // CRITICAL: Accurate conversion from basis points to percentage
            const earlyFeePercent = (contract.earlyFee.toNumber() / 100).toFixed(2);
            const apyPercent = (contract.apy.toNumber() / 100).toFixed(2);
            
            // CRITICAL: Use actual contract lockPeriod for accurate conversion from seconds to days
            const lockPeriodDays = Math.round(actualLockPeriod.toNumber() / 86400);
            
            // CRITICAL: Accurate token amount display
            const minStakeFormatted = ethers.utils.formatEther(contract.minStake);

            // Get contract stats for professional display
            let contractStats = '';
            try {
                const stakingContract = new ethers.Contract(contract.contractAddress, STAKING_ABI, provider);
                const totalStaked = await stakingContract.totalStaked();
                const totalRewards = await stakingContract.totalRewards();
                
                let userStake = ethers.BigNumber.from(0);
                let userRewards = ethers.BigNumber.from(0);
                let userBalance = ethers.BigNumber.from(0);

                if (userAddress) {
                    try {
                        userStake = await stakingContract.getStakedAmount(userAddress);
                        userRewards = await stakingContract.getPendingRewards(userAddress);
                        
                        // Get user's available balance for staking
                        if (stakingTokenInfo.symbol === 'ETH') {
                            userBalance = await provider.getBalance(userAddress);
                        } else {
                            const tokenContract = new ethers.Contract(contract.stakingToken, ERC20_ABI, provider);
                            userBalance = await tokenContract.balanceOf(userAddress);
                        }
                    } catch (err) {
                        console.warn('Could not load user stats for contract:', err.message);
                    }
                }

                contractStats = `
                    <div class="user-stats">
                        <h4>Contract & User Statistics</h4>
                        <div class="info-row">
                            <span class="info-label">Total Value Locked:</span>
                            <span class="info-value">${ethers.utils.formatEther(totalStaked)} ${stakingTokenInfo.symbol}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Total Rewards Distributed:</span>
                            <span class="info-value">${ethers.utils.formatEther(totalRewards)} ${rewardTokenInfo.symbol}</span>
                        </div>
                        ${userAddress ? `
                        <div class="info-row">
                            <span class="info-label">Your Staked:</span>
                            <span class="info-value">${ethers.utils.formatEther(userStake)} ${stakingTokenInfo.symbol}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Your Pending Rewards:</span>
                            <span class="info-value" data-rewards-display data-contract="${contract.contractAddress}">${ethers.utils.formatEther(userRewards)} ${rewardTokenInfo.symbol}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Available to Stake:</span>
                            <span class="info-value">${ethers.utils.formatEther(userBalance)} ${stakingTokenInfo.symbol}</span>
                        </div>
                        ` : ''}
                    </div>
                `;
            } catch (error) {
                console.warn('Could not load contract stats:', error.message);
            }

            return `
                <div class="contract-card">
                    <div class="contract-title">${contract.name}</div>
                    <div class="contract-info">
                        <div class="info-row">
                            <span class="info-label">Contract Address:</span>
                            <div class="token-info">
                                <span class="info-value">${contract.contractAddress.substring(0, 8)}...${contract.contractAddress.substring(34)}</span>
                                <button class="copy-btn" onclick="copyToClipboard('${contract.contractAddress}', this)">Copy</button>
                            </div>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Original Creator:</span>
                            <div class="token-info">
                                <span class="info-value">${contract.creator.substring(0, 6)}...${contract.creator.substring(38)}</span>
                                <button class="copy-btn" onclick="copyToClipboard('${contract.creator}', this)">Copy</button>
                            </div>
                        </div>
                        ${currentOwner.toLowerCase() !== contract.creator.toLowerCase() ? `
                        <div class="info-row">
                            <span class="info-label">Current Owner:</span>
                            <div class="token-info">
                                <span class="info-value" style="color: var(--console-green); font-weight: bold;">${currentOwner.substring(0, 6)}...${currentOwner.substring(38)}</span>
                                <button class="copy-btn" onclick="copyToClipboard('${currentOwner}', this)">Copy</button>
                            </div>
                        </div>
                        ` : ''}
                        <div class="info-row">
                            <span class="info-label">Staking Token:</span>
                            <div class="token-info">
                                <span class="info-value">${stakingTokenDisplay}</span>
                                ${stakingTokenInfo.symbol !== 'ETH' ? `<span class="token-ticker">${stakingTokenInfo.symbol}</span>` : ''}
                                ${stakingTokenInfo.symbol !== 'ETH' ? `<button class="copy-btn" onclick="copyToClipboard('${contract.stakingToken}', this)">Copy</button>` : ''}
                            </div>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Reward Token:</span>
                            <div class="token-info">
                                <span class="info-value">${rewardTokenDisplay}</span>
                                ${rewardTokenInfo.symbol !== 'ETH' ? `<span class="token-ticker">${rewardTokenInfo.symbol}</span>` : ''}
                                ${rewardTokenInfo.symbol !== 'ETH' ? `<button class="copy-btn" onclick="copyToClipboard('${contract.rewardToken}', this)">Copy</button>` : ''}
                            </div>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Early Withdrawal Fee Period:</span>
                            <span class="info-value">${lockPeriodDays} days</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Early Withdrawal Fee:</span>
                            <span class="info-value">${earlyFeePercent}%</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">APY:</span>
                            <span class="info-value">${apyPercent}%</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Min Stake:</span>
                            <span class="info-value">${minStakeFormatted} ${stakingTokenInfo.symbol}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Created:</span>
                            <span class="info-value">${createdDate}</span>
                        </div>
                    </div>
                    ${contractStats}
                    ${isOwner ? `
                        <div class="admin-section">
                            <div class="admin-title">Admin Controls</div>
                            <div class="contract-actions">
                                <button class="btn btn-secondary" onclick="console.log('ðŸ”´ DEPOSIT BUTTON CLICKED'); openDepositRewardsModal('${contract.contractAddress}', '${rewardTokenInfo.symbol}')">
                                    Deposit Rewards
                                </button>
                                <button class="btn btn-secondary" onclick="console.log('ðŸ”´ EMERGENCY BUTTON CLICKED'); openEmergencyWithdrawModal('${contract.contractAddress}')">
                                    Emergency Withdraw
                                </button>
                                <button class="btn btn-secondary" onclick="console.log('ðŸ”´ WITHDRAW FEES/REWARDS BUTTON CLICKED'); openWithdrawFeesModal('${contract.contractAddress}')">
                                    Withdraw Fees/Rewards
                                </button>
                                <button class="btn btn-secondary" onclick="console.log('ðŸ”´ TRANSFER OWNERSHIP BUTTON CLICKED'); openTransferOwnershipModal('${contract.contractAddress}')">
                                    Transfer Ownership
                                </button>
                            </div>
                        </div>
                    ` : ''}
                    <div class="contract-actions">
                        <button class="btn" onclick="openStakingModal('${contract.contractAddress}', '${contract.name}')">
                            Stake & Manage
                        </button>
                        <button class="btn btn-secondary" onclick="viewOnBasescan('${contract.contractAddress}')">
                            View on Basescan
                        </button>
                    </div>
                </div>
            `;
        }

        // Update statistics with accurate calculations
        async function updateStats() {
            try {
                // Check if factoryContract is initialized
                if (!factoryContract) {
                    console.log('Factory contract not initialized, skipping stats update');
                    return;
                }

                const totalContractsRaw = await factoryContract.getDeployedContractsCount();
                
                // Filter out blacklisted contracts for accurate count
                let activeContractsCount = 0;
                let userContractsCount = 0;
                let totalValueLocked = ethers.BigNumber.from(0);
                
                const count = totalContractsRaw.toNumber();
                for (let i = 0; i < count; i++) {
                    try {
                        const contractInfo = await factoryContract.getContractInfo(i);
                        
                        // Skip blacklisted contracts
                        if (isBlacklisted(contractInfo)) {
                            continue;
                        }
                        
                        activeContractsCount++;
                        
                        // Count user contracts (only active ones)
                        if (userAddress && contractInfo.creator.toLowerCase() === userAddress.toLowerCase()) {
                            userContractsCount++;
                        }
                        
                        // Calculate TVL (only for active contracts)
                        try {
                            const stakingContract = new ethers.Contract(contractInfo.contractAddress, STAKING_ABI, provider);
                            const totalStaked = await stakingContract.totalStaked();
                            totalValueLocked = totalValueLocked.add(totalStaked);
                        } catch (err) {
                            console.warn(`Could not get TVL for contract ${contractInfo.contractAddress}:`, err.message);
                        }
                        
                    } catch (err) {
                        console.warn(`Could not process contract ${i}:`, err.message);
                    }
                }
                
                // Update UI with filtered counts
                document.getElementById('totalContracts').textContent = activeContractsCount.toString();
                
                if (userAddress) {
                    document.getElementById('userContracts').textContent = userContractsCount.toString();
                }
                
                const tvlFormatted = parseFloat(ethers.utils.formatEther(totalValueLocked)).toFixed(2);
                document.getElementById('totalStaked').textContent = `${tvlFormatted}`;

            } catch (error) {
                console.error('Error updating stats:', error);
                document.getElementById('totalContracts').textContent = 'Error';
            }
        }

        // Open staking modal with CRITICAL accuracy for user funds
        async function openStakingModal(contractAddress, contractName) {
            try {
                document.getElementById('modalTitle').textContent = contractName;
                const modal = document.getElementById('stakingModal');
                const modalContent = document.getElementById('modalContent');

                modalContent.innerHTML = '<div class="loading"><div class="spinner"></div></div>';
                modal.style.display = 'block';

                // Create staking contract instance
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, provider);

                // Get contract details with error handling
                let contractData;
                try {
                    const [stakingToken, rewardToken, lockPeriod, earlyFee, apy, minStake, totalStaked] = await Promise.all([
                        stakingContract.stakingToken(),
                        stakingContract.rewardToken(),
                        stakingContract.lockPeriod(),
                        stakingContract.earlyFee(),
                        stakingContract.apy(),
                        stakingContract.minStake(),
                        stakingContract.totalStaked()
                    ]);
                    
                    contractData = {
                        stakingToken,
                        rewardToken,
                        lockPeriod,
                        earlyFee,
                        apy,
                        minStake,
                        totalStaked
                    };
                } catch (error) {
                    throw new Error(`Failed to load contract data: ${error.message}`);
                }

                // Initialize user data variables with safe defaults
                let userStake = ethers.BigNumber.from(0);
                let userRewards = ethers.BigNumber.from(0);
                let userTimestamp = ethers.BigNumber.from(0);
                let canWithdraw = false;
                let timeLeft = 'N/A';
                let hasUserData = false;

                // Get user-specific data if wallet is connected
                if (userAddress && signer) {
                    try {
                        const stakingContractSigner = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                        
                        // Get all user data in parallel for accuracy
                        const [userStakeData, userRewardsData, userTimestampData, canWithdrawData] = await Promise.all([
                            stakingContractSigner.getStakedAmount(userAddress),
                            stakingContractSigner.getPendingRewards(userAddress),
                            stakingContractSigner.getStakeTimestamp(userAddress),
                            stakingContractSigner.canWithdrawWithoutFee(userAddress)
                        ]);

                        userStake = userStakeData;
                        userRewards = userRewardsData;
                        userTimestamp = userTimestampData;
                        canWithdraw = canWithdrawData;
                        hasUserData = true;

                        // CRITICAL: Accurate time calculation
                        if (userTimestamp.gt(0)) {
                            // Contract stores lockPeriod in seconds, userTimestamp in seconds
                            const unlockTimestamp = userTimestamp.add(contractData.lockPeriod);
                            const currentTimestamp = Math.floor(Date.now() / 1000);
                            const secondsLeft = unlockTimestamp.toNumber() - currentTimestamp;
                            
                            if (secondsLeft > 0) {
                                const days = Math.floor(secondsLeft / 86400);
                                const hours = Math.floor((secondsLeft % 86400) / 3600);
                                const minutes = Math.floor((secondsLeft % 3600) / 60);
                                timeLeft = `${days}d ${hours}h ${minutes}m`;
                            } else {
                                timeLeft = 'Unlocked';
                            }
                        }
                    } catch (err) {
                        console.warn('Could not load user data (user may not have staked):', err.message);
                        // Keep default values, don't throw error
                    }
                }

                // Determine token types for accurate display
                const isEthStaking = contractData.stakingToken === ethers.constants.AddressZero;
                const isEthReward = contractData.rewardToken === ethers.constants.AddressZero;

                // CRITICAL: Accurate basis points to percentage conversion
                const apyPercent = (contractData.apy.toNumber() / 100).toFixed(2);
                const earlyFeePercent = (contractData.earlyFee.toNumber() / 100).toFixed(2);
                
                // CRITICAL: Accurate time conversion (seconds to days)
                const lockPeriodDays = Math.round(contractData.lockPeriod.toNumber() / 86400);

                modalContent.innerHTML = `
                    <div class="contract-info">
                        <div class="info-row">
                            <span class="info-label">Contract Address:</span>
                            <span class="info-value">${contractAddress}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Total Staked:</span>
                            <span class="info-value">${ethers.utils.formatEther(contractData.totalStaked)} ${isEthStaking ? 'ETH' : 'tokens'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">APY:</span>
                            <span class="info-value">${apyPercent}%</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Early Withdrawal Fee Period:</span>
                            <span class="info-value">${lockPeriodDays} days</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Early Withdrawal Fee:</span>
                            <span class="info-value">${earlyFeePercent}%</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Minimum Stake:</span>
                            <span class="info-value">${ethers.utils.formatEther(contractData.minStake)} ${isEthStaking ? 'ETH' : 'tokens'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Staking Token:</span>
                            <span class="info-value">${isEthStaking ? 'ETH' : contractData.stakingToken}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Reward Token:</span>
                            <span class="info-value">${isEthReward ? 'ETH' : contractData.rewardToken}</span>
                        </div>
                    </div>

                    ${userAddress ? `
                        <h3 style="color: var(--accent-color); margin: 20px 0 10px 0;">Your Position</h3>
                        <div class="contract-info">
                            <div class="info-row">
                                <span class="info-label">Staked Amount:</span>
                                <span class="info-value">${ethers.utils.formatEther(userStake)} ${isEthStaking ? 'ETH' : 'tokens'}</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Pending Rewards:</span>
                                <span class="info-value" data-rewards-display>${ethers.utils.formatEther(userRewards)} ${isEthReward ? 'ETH' : 'tokens'}</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Time Until Unlock:</span>
                                <span class="info-value">${timeLeft}</span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Can Withdraw Without Fee:</span>
                                <span class="info-value" style="color: ${canWithdraw ? 'var(--success-color)' : 'var(--warning-color)'};">
                                    ${canWithdraw ? 'Yes' : 'No'}
                                </span>
                            </div>
                            <div class="info-row">
                                <span class="info-label">Max Withdrawable:</span>
                                <span class="info-value">${ethers.utils.formatEther(userStake)} ${isEthStaking ? 'ETH' : 'tokens'}</span>
                            </div>
                        </div>

                        <div style="margin-top: 20px;">
                            <div class="form-group">
                                <label>Amount to Stake/Withdraw:</label>
                                <input type="number" id="stakeAmount" class="form-input" placeholder="0.0" step="0.000001" min="0">
                                <div style="font-size: 0.8em; color: var(--secondary-text); margin-top: 5px;">
                                    Min stake: ${ethers.utils.formatEther(contractData.minStake)} | Your balance: ${ethers.utils.formatEther(userStake)}
                                </div>
                            </div>
                            <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-top: 10px;">
                                <button class="btn" onclick="performStake('${contractAddress}', ${isEthStaking})">Stake</button>
                                <button class="btn" onclick="performWithdraw('${contractAddress}')">Withdraw</button>
                                <button class="btn btn-secondary" onclick="claimRewards('${contractAddress}')">Claim Rewards</button>
                            </div>
                        </div>
                    ` : `
                        <div style="text-align: center; margin: 20px 0;">
                            <p style="color: var(--secondary-text);">Connect your wallet to stake in this contract</p>
                            <button class="btn" onclick="connectWallet()">Connect Wallet</button>
                        </div>
                    `}
                `;

            } catch (error) {
                console.error('Error opening staking modal:', error);
                modalContent.innerHTML = `<p style="color: var(--error-color);">Error loading contract details: ${error.message}</p>`;
            }
            
            // Set up auto-refresh for rewards (update every 10 seconds)
            if (rewardsRefreshTimer) {
                clearInterval(rewardsRefreshTimer);
            }
            
            rewardsRefreshTimer = setInterval(async () => {
                try {
                    if (!userAddress || !signer) return;
                    
                    const modal = document.getElementById('stakingModal');
                    if (modal && modal.style.display !== 'none') {
                        // Update modal rewards
                        const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, provider);
                        const pendingRewards = await stakingContract.getPendingRewards(userAddress);
                        const rewardsFormatted = ethers.utils.formatEther(pendingRewards);
                        
                        const modalRewardsElements = modal.querySelectorAll('[data-rewards-display]:not([data-contract])');
                        modalRewardsElements.forEach(element => {
                            const currentText = element.textContent;
                            const parts = currentText.split(' ');
                            const tokenPart = parts.slice(-1)[0]; // Get last part (token symbol)
                            element.textContent = `${rewardsFormatted} ${tokenPart}`;
                        });
                    }
                    
                    // Also refresh main directory rewards
                    await refreshAllRewards();
                } catch (error) {
                    console.warn('Error refreshing rewards:', error.message);
                }
            }, 10000); // Update every 10 seconds
        }

        // Global variable to track rewards refresh timer
        let rewardsRefreshTimer = null;
        
        // Auto-refresh rewards across all displays
        async function refreshAllRewards() {
            if (!userAddress || !signer) return;
            
            try {
                // Get all contracts with rewards displays
                const rewardsElements = document.querySelectorAll('[data-rewards-display]');
                
                for (const element of rewardsElements) {
                    const contractAddress = element.getAttribute('data-contract');
                    if (contractAddress) {
                        // This is a main directory display
                        try {
                            const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, provider);
                            const pendingRewards = await stakingContract.getPendingRewards(userAddress);
                            const rewardsFormatted = ethers.utils.formatEther(pendingRewards);
                            
                            // Update the text content (keeping the token symbol)
                            const currentText = element.textContent;
                            const tokenSymbol = currentText.split(' ').slice(-1)[0]; // Get last word (token symbol)
                            element.textContent = `${rewardsFormatted} ${tokenSymbol}`;
                        } catch (error) {
                            console.warn(`Error updating rewards for contract ${contractAddress}:`, error.message);
                        }
                    } else {
                        // This is a modal display - update if modal is open
                        const modal = document.getElementById('stakingModal');
                        if (modal && modal.style.display !== 'none') {
                            // Get contract address from modal title or URL
                            const modalTitle = document.getElementById('modalTitle').textContent;
                            // For modal updates, we need to identify the contract - let's get it from the active modal
                            // We'll handle this in the modal-specific timer
                        }
                    }
                }
            } catch (error) {
                console.warn('Error in refreshAllRewards:', error.message);
            }
        }

        // Close modal
        function closeModal() {
            document.getElementById('stakingModal').style.display = 'none';
            
            // Clear rewards refresh timer when modal closes
            if (rewardsRefreshTimer) {
                clearInterval(rewardsRefreshTimer);
                rewardsRefreshTimer = null;
            }
        }

        // Perform stake with CRITICAL validation to prevent fund loss
        async function performStake(contractAddress, isEthStaking) {
            if (!signer) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            try {
                const amountInput = document.getElementById('stakeAmount').value.trim();
                if (!amountInput || parseFloat(amountInput) <= 0) {
                    showStatus('Please enter a valid amount greater than 0', 'error');
                    return;
                }

                // CRITICAL: Precise amount parsing and validation
                const amountFloat = parseFloat(amountInput);
                if (isNaN(amountFloat) || amountFloat <= 0) {
                    showStatus('Invalid amount entered', 'error');
                    return;
                }

                // Convert to Wei with precision check
                let amountWei;
                try {
                    amountWei = ethers.utils.parseEther(amountInput);
                } catch (error) {
                    showStatus('Invalid amount format. Use decimal notation (e.g., 1.5)', 'error');
                    return;
                }

                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                
                // CRITICAL: Check minimum stake requirement
                const minStake = await stakingContract.minStake();
                if (amountWei.lt(minStake)) {
                    const minStakeFormatted = ethers.utils.formatEther(minStake);
                    showStatus(`Amount must be at least ${minStakeFormatted} tokens`, 'error');
                    return;
                }

                // CRITICAL: For ETH staking, check user's ETH balance
                if (isEthStaking) {
                    const balance = await signer.getBalance();
                    const gasEstimate = ethers.utils.parseEther('0.001'); // Reserve for gas
                    
                    if (balance.sub(gasEstimate).lt(amountWei)) {
                        const balanceFormatted = ethers.utils.formatEther(balance);
                        showStatus(`Insufficient ETH balance. You have ${balanceFormatted} ETH`, 'error');
                        return;
                    }
                }

                // Show confirmation in modal instead of confirm()
                document.getElementById('confirmStakeAmount').innerHTML = `<strong style="color: var(--console-green);">${amountInput} ${isEthStaking ? 'ETH' : 'TOKEN'}</strong>`;
                document.getElementById('confirmStakeContract').textContent = `${contractAddress.slice(0, 6)}...${contractAddress.slice(-4)}`;
                document.getElementById('confirmStakeType').innerHTML = `<strong>${isEthStaking ? 'ETH Staking' : 'Token Staking'}</strong>`;

                // Store staking details for execution
                window.pendingStake = {
                    contractAddress: contractAddress,
                    amountWei: amountWei,
                    amountInput: amountInput,
                    isEthStaking: isEthStaking
                };
                
                // Show confirmation modal
                document.getElementById('stakeConfirmModal').style.display = 'flex';

            } catch (error) {
                console.error('Error staking:', error);
                console.error('Error details:', {
                    message: error.message,
                    code: error.code,
                    data: error.data,
                    reason: error.reason
                });
                let errorMessage = 'Staking failed: ';
                if (error.code === 'INSUFFICIENT_FUNDS') {
                    errorMessage += 'Insufficient funds for gas or amount';
                } else if (error.message && error.message.includes('user rejected')) {
                    errorMessage += 'Transaction rejected by user';
                } else {
                    errorMessage += error.message;
                }
                showStatus(errorMessage, 'error');
            }
        }

        // Execute stake after modal confirmation
        async function executeStake() {
            if (!window.pendingStake) {
                showStatus('No pending stake found', 'error');
                return;
            }

            try {
                const { contractAddress, amountWei, amountInput, isEthStaking } = window.pendingStake;
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);

                let tx;
                if (isEthStaking) {
                    // For ETH staking, amount parameter should be 0 and ETH sent via value
                    tx = await stakingContract.stake(0, { 
                        value: amountWei,
                        gasLimit: 300000 // Set reasonable gas limit
                    });
                } else {
                    // For token staking, user must approve tokens first
                    console.log('Token staking detected. Checking allowance...');
                    
                    // Get staking token address
                    const stakingTokenAddress = await stakingContract.stakingToken();
                    
                    const tokenContract = new ethers.Contract(stakingTokenAddress, [
                        "function approve(address spender, uint256 amount) external returns (bool)",
                        "function allowance(address owner, address spender) external view returns (uint256)"
                    ], signer);
                    
                    // Check current allowance
                    const currentAllowance = await tokenContract.allowance(userAddress, contractAddress);
                    console.log('Current staking allowance:', ethers.utils.formatEther(currentAllowance));
                    
                    if (currentAllowance.lt(amountWei)) {
                        console.log('Insufficient allowance for staking, requesting approval...');
                        showStatus('Approving tokens for staking... Please confirm the approval transaction first.', 'warning');
                        
                        const approveTx = await tokenContract.approve(contractAddress, amountWei);
                        console.log('Staking approval transaction submitted:', approveTx.hash);
                        showStatus('Waiting for staking approval confirmation...', 'warning');
                        await approveTx.wait();
                        console.log('Staking approval confirmed');
                        showStatus('Approval confirmed. Now staking tokens...', 'warning');
                    }
                    
                    console.log('Sending token staking transaction:', { amount: amountWei.toString() });
                    tx = await stakingContract.stake(amountWei, {
                        gasLimit: 300000
                    });
                }

                closeAdminModal('stakeConfirmModal');
                showStatus(`Staking transaction submitted: ${tx.hash}`, 'warning');
                const receipt = await tx.wait();
                
                if (receipt.status === 1) {
                    showStatus(`Successfully staked ${amountInput} ${isEthStaking ? 'ETH' : 'tokens'}!`, 'success');
                } else {
                    throw new Error('Transaction failed');
                }

                // Clear input and refresh modal
                document.getElementById('stakeAmount').value = '';
                setTimeout(() => {
                    const contractName = document.getElementById('modalTitle').textContent.replace(' - Staking Interface', '');
                    openStakingModal(contractAddress, contractName);
                }, 2000);

            } catch (error) {
                closeAdminModal('stakeConfirmModal');
                console.error('Error staking:', error);
                console.error('Error details:', {
                    message: error.message,
                    code: error.code,
                    data: error.data,
                    reason: error.reason
                });
                let errorMessage = 'Staking failed: ';
                if (error.code === 'INSUFFICIENT_FUNDS') {
                    errorMessage += 'Insufficient funds for gas or amount';
                } else if (error.message && error.message.includes('user rejected')) {
                    errorMessage += 'Transaction rejected by user';
                } else {
                    errorMessage += error.message;
                }
                showStatus(errorMessage, 'error');
            } finally {
                window.pendingStake = null;
            }
        }

        // Perform withdraw with CRITICAL safety checks
        async function performWithdraw(contractAddress) {
            if (!signer) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            try {
                const amountInput = document.getElementById('stakeAmount').value.trim();
                if (!amountInput || parseFloat(amountInput) <= 0) {
                    showStatus('Please enter a valid amount greater than 0', 'error');
                    return;
                }

                // CRITICAL: Precise amount parsing
                const amountFloat = parseFloat(amountInput);
                if (isNaN(amountFloat) || amountFloat <= 0) {
                    showStatus('Invalid amount entered', 'error');
                    return;
                }

                let amountWei;
                try {
                    amountWei = ethers.utils.parseEther(amountInput);
                } catch (error) {
                    showStatus('Invalid amount format. Use decimal notation (e.g., 1.5)', 'error');
                    return;
                }

                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                
                // CRITICAL: Check user's staked balance
                const userStakedAmount = await stakingContract.getStakedAmount(userAddress);
                if (amountWei.gt(userStakedAmount)) {
                    const stakedFormatted = ethers.utils.formatEther(userStakedAmount);
                    showStatus(`Cannot withdraw ${amountInput}. You only have ${stakedFormatted} staked.`, 'error');
                    return;
                }

                if (userStakedAmount.eq(0)) {
                    showStatus('You have no tokens staked in this contract', 'error');
                    return;
                }

                // CRITICAL: Check withdrawal conditions and calculate fees
                const canWithdrawFree = await stakingContract.canWithdrawWithoutFee(userAddress);
                const earlyFee = await stakingContract.earlyFee();
                
                let feeAmount = ethers.BigNumber.from(0);
                let warningMessage = '';
                
                if (!canWithdrawFree) {
                    // Calculate exact fee in Wei
                    feeAmount = amountWei.mul(earlyFee).div(10000); // earlyFee is in basis points
                    const feeFormatted = ethers.utils.formatEther(feeAmount);
                    const feePercent = (earlyFee.toNumber() / 100).toFixed(2);
                    
                    warningMessage = `
                        âš ï¸ EARLY WITHDRAWAL WARNING:
                        â€¢ Withdrawal amount: ${amountInput}
                        â€¢ Early withdrawal fee: ${feePercent}% (${feeFormatted} tokens)
                        â€¢ You will receive: ${ethers.utils.formatEther(amountWei.sub(feeAmount))}
                        â€¢ Fee goes to contract owner
                    `;
                }

                // Show detailed confirmation in modal instead of confirm()
                const userTimestamp = await stakingContract.getStakeTimestamp(userAddress);
                const lockPeriod = await stakingContract.lockPeriod();
                const unlockTime = userTimestamp.add(lockPeriod);
                const unlockDate = new Date(unlockTime.toNumber() * 1000);

                // Populate withdrawal confirmation modal
                document.getElementById('confirmWithdrawAmount').innerHTML = `<strong style="color: var(--console-green);">${amountInput}</strong>`;
                document.getElementById('confirmStakedBalance').innerHTML = `<strong>${ethers.utils.formatEther(userStakedAmount)}</strong>`;
                document.getElementById('confirmUnlockDate').innerHTML = `<strong>${unlockDate.toLocaleString()}</strong>`;
                document.getElementById('confirmEarlyWithdraw').innerHTML = canWithdrawFree ? 
                    `<strong style="color: var(--console-green);">No</strong>` : 
                    `<strong style="color: var(--console-red);">Yes</strong>`;
                document.getElementById('confirmWithdrawWarning').innerHTML = warningMessage ? 
                    `<div style="color: var(--console-red); font-weight: bold; padding: 0.5rem; border: 1px solid var(--console-red); border-radius: 4px;">${warningMessage}</div>` : '';

                // Store withdrawal details for execution
                window.pendingWithdrawal = {
                    contractAddress: contractAddress,
                    amountWei: amountWei,
                    amountInput: amountInput
                };
                
                // Show confirmation modal
                document.getElementById('withdrawConfirmModal').style.display = 'flex';

            } catch (error) {
                console.error('Error preparing withdrawal:', error);
                showStatus('Failed to prepare withdrawal: ' + error.message, 'error');
            }
        }

        // Execute withdrawal after modal confirmation
        async function executeWithdrawal() {
            if (!window.pendingWithdrawal) {
                showStatus('No pending withdrawal found', 'error');
                return;
            }

            try {
                const { contractAddress, amountWei, amountInput } = window.pendingWithdrawal;
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);

                const tx = await stakingContract.withdraw(amountWei, {
                    gasLimit: 300000
                });

                closeAdminModal('withdrawConfirmModal');
                showStatus(`Withdrawal transaction submitted: ${tx.hash}`, 'warning');
                const receipt = await tx.wait();
                
                if (receipt.status === 1) {
                    showStatus(`Successfully withdrew ${amountInput}!`, 'success');
                    
                    // Clear input and refresh modal
                    document.getElementById('stakeAmount').value = '';
                    setTimeout(() => {
                        const contractName = document.getElementById('modalTitle').textContent.replace(' - Staking Interface', '');
                        openStakingModal(contractAddress, contractName);
                    }, 2000);
                } else {
                    throw new Error('Transaction failed');
                }

            } catch (error) {
                closeAdminModal('withdrawConfirmModal');
                console.error('Error during withdrawal:', error);
                let errorMessage = 'Withdrawal failed: ';
                if (error.code === 'INSUFFICIENT_FUNDS') {
                    errorMessage += 'Insufficient funds for gas or amount';
                } else if (error.message && error.message.includes('user rejected')) {
                    errorMessage += 'Transaction rejected by user';
                } else if (error.message && error.message.includes('lock period')) {
                    errorMessage += 'Lock period not met or insufficient balance';
                } else {
                    errorMessage += error.message;
                }
                showStatus(errorMessage, 'error');
            } finally {
                window.pendingWithdrawal = null;
            }
        }

        // Claim rewards function (modal-based for wallet browser compatibility)
        async function claimRewards(contractAddress) {
            if (!signer) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            try {
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                
                // CRITICAL: Check if user has any rewards to claim
                const pendingRewards = await stakingContract.getPendingRewards(userAddress);
                if (pendingRewards.eq(0)) {
                    showStatus('No rewards available to claim', 'warning');
                    return;
                }

                const rewardsFormatted = ethers.utils.formatEther(pendingRewards);
                const rewardToken = await stakingContract.rewardToken();
                const isEthReward = rewardToken === ethers.constants.AddressZero;

                // Populate confirmation modal instead of using confirm()
                document.getElementById('confirmClaimAmount').innerHTML = `<strong style="color: var(--console-green);">${rewardsFormatted} ${isEthReward ? 'ETH' : 'TOKEN'}</strong>`;
                document.getElementById('confirmClaimContract').textContent = `${contractAddress.slice(0, 6)}...${contractAddress.slice(-4)}`;

                // Store contract address for execution
                window.pendingClaimContract = contractAddress;
                
                // Show confirmation modal
                document.getElementById('claimConfirmModal').style.display = 'flex';

            } catch (error) {
                console.error('Error preparing reward claim:', error);
                showStatus('Failed to prepare reward claim: ' + error.message, 'error');
            }
        }

        // Execute claim rewards after modal confirmation
        async function executeClaimRewards() {
            if (!window.pendingClaimContract) {
                showStatus('No pending claim found', 'error');
                return;
            }

            try {
                const stakingContract = new ethers.Contract(window.pendingClaimContract, STAKING_ABI, signer);

                const tx = await stakingContract.claimRewards({
                    gasLimit: 200000
                });

                closeAdminModal('claimConfirmModal');
                showStatus(`Claiming rewards transaction submitted: ${tx.hash}`, 'warning');
                const receipt = await tx.wait();

                if (receipt.status === 1) {
                    showStatus('Rewards claimed successfully!', 'success');
                    
                    // Refresh the modal if it's still open
                    setTimeout(() => {
                        const openModal = document.getElementById('stakingModal');
                        if (openModal.style.display !== 'none') {
                            const modalTitle = document.getElementById('modalTitle').textContent;
                            const contractName = modalTitle.replace(' - Staking Interface', '');
                            openStakingModal(window.pendingClaimContract, contractName);
                        }
                    }, 2000);
                } else {
                    throw new Error('Transaction failed');
                }

            } catch (error) {
                closeAdminModal('claimConfirmModal');
                console.error('Error claiming rewards:', error);
                let errorMessage = 'Reward claim failed: ';
                if (error.code === 'INSUFFICIENT_FUNDS') {
                    errorMessage += 'Insufficient funds for gas';
                } else if (error.message && error.message.includes('user rejected')) {
                    errorMessage += 'Transaction rejected by user';
                } else {
                    errorMessage += error.message;
                }
                showStatus(errorMessage, 'error');
            } finally {
                window.pendingClaimContract = null;
            }
        }

        // Admin Functions for Contract Creators - Modal-Based (Coinbase Wallet Compatible)

        // Modal management functions
        function closeAdminModal(modalId) {
            console.log('ðŸ”§ closeAdminModal called with:', { modalId });
            const modal = document.getElementById(modalId);
            console.log('ðŸ”§ Modal element found:', !!modal);
            if (modal) {
                modal.style.display = 'none';
                console.log('âœ… Modal hidden successfully');
            } else {
                console.error('âŒ Modal element not found:', modalId);
            }
        }

        // Open deposit rewards modal
        async function openDepositRewardsModal(contractAddress, rewardTokenSymbol) {
            console.log('ðŸ”§ openDepositRewardsModal called with:', { contractAddress, rewardTokenSymbol });
            console.log('ðŸ”§ Signer available:', !!signer);
            
            if (!signer) {
                console.error('âŒ No signer available');
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            try {
                console.log('ðŸ”§ Creating staking contract...');
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                console.log('ðŸ”§ Getting reward token...');
                const rewardToken = await stakingContract.rewardToken();
                console.log('ðŸ”§ Reward token:', rewardToken);
                const isEthReward = rewardToken === ethers.constants.AddressZero;
                console.log('ðŸ”§ Is ETH reward:', isEthReward);

                // Get balance information
                let userBalance = '0';
                let contractBalance = '0';

                try {
                    if (isEthReward) {
                        userBalance = await signer.getBalance();
                        contractBalance = await provider.getBalance(contractAddress);
                    } else {
                        const tokenContract = new ethers.Contract(rewardToken, [
                            "function balanceOf(address owner) external view returns (uint256)"
                        ], provider);
                        userBalance = await tokenContract.balanceOf(userAddress);
                        contractBalance = await tokenContract.balanceOf(contractAddress);
                    }
                } catch (e) {
                    console.warn('Could not get balance info:', e);
                }

                // Populate modal
                console.log('ðŸ”§ Populating modal elements...');
                const contractElement = document.getElementById('depositContractAddress');
                const tokenElement = document.getElementById('depositRewardToken');
                const balanceElement = document.getElementById('depositUserBalance');
                const contractBalanceElement = document.getElementById('depositContractBalance');
                
                console.log('ðŸ”§ Modal elements found:', {
                    contract: !!contractElement,
                    token: !!tokenElement,
                    balance: !!balanceElement,
                    contractBalance: !!contractBalanceElement
                });
                
                if (contractElement) contractElement.textContent = contractAddress;
                if (tokenElement) tokenElement.textContent = `${rewardTokenSymbol} (${isEthReward ? 'ETH' : 'Token'})`;
                if (balanceElement) balanceElement.textContent = `${ethers.utils.formatEther(userBalance)} ${rewardTokenSymbol}`;
                if (contractBalanceElement) contractBalanceElement.textContent = `${ethers.utils.formatEther(contractBalance)} ${rewardTokenSymbol}`;

                // Show modal
                console.log('ðŸ”§ Showing modal...');
                const modal = document.getElementById('depositRewardsModal');
                console.log('ðŸ”§ Modal element found:', !!modal);
                if (modal) {
                    modal.style.display = 'flex';
                    console.log('âœ… Modal should now be visible');
                } else {
                    console.error('âŒ Modal element not found!');
                }

                // Handle form submission
                const form = document.getElementById('depositRewardsForm');
                form.onsubmit = async (e) => {
                    e.preventDefault();
                    const amount = document.getElementById('depositAmount').value;
                    await executeDepositRewards(contractAddress, amount, rewardTokenSymbol, isEthReward);
                    closeAdminModal('depositRewardsModal');
                };

            } catch (error) {
                console.error('âŒ Error opening deposit modal:', error);
                console.error('âŒ Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                showStatus('Error opening deposit modal: ' + error.message, 'error');
            }
        }

        // Execute deposit rewards
        async function executeDepositRewards(contractAddress, amount, rewardTokenSymbol, isEthReward) {
            if (!amount || parseFloat(amount) <= 0) {
                showStatus('Invalid amount entered', 'error');
                return;
            }

            try {
                const amountWei = ethers.utils.parseEther(amount);
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);

                let tx;
                if (isEthReward) {
                    tx = await stakingContract.depositRewards(0, { 
                        value: amountWei,
                        gasLimit: 300000
                    });
                } else {
                    const rewardToken = await stakingContract.rewardToken();
                    const tokenContract = new ethers.Contract(rewardToken, [
                        "function allowance(address owner, address spender) external view returns (uint256)",
                        "function approve(address spender, uint256 amount) external returns (bool)"
                    ], signer);

                    const currentAllowance = await tokenContract.allowance(userAddress, contractAddress);
                    if (currentAllowance.lt(amountWei)) {
                        showStatus('Approving tokens for deposit...', 'warning');
                        const approveTx = await tokenContract.approve(contractAddress, amountWei);
                        await approveTx.wait();
                    }

                    tx = await stakingContract.depositRewards(amountWei, {
                        gasLimit: 300000
                    });
                }

                showStatus('Depositing rewards...', 'warning');
                await tx.wait();
                showStatus(`Successfully deposited ${amount} ${rewardTokenSymbol} as rewards!`, 'success');
                
                setTimeout(() => loadContractsDirectory(), 2000);

            } catch (error) {
                console.error('Error depositing rewards:', error);
                showStatus('Failed to deposit rewards: ' + error.message, 'error');
            }
        }

        // Open withdraw fees modal (replaces withdraw excess - shows only withdrawable fees)
        async function openWithdrawFeesModal(contractAddress) {
            console.log('ðŸ”§ openWithdrawFeesModal called with:', { contractAddress });
            console.log('ðŸ”§ Signer available:', !!signer);
            
            if (!signer) {
                console.error('âŒ No signer available');
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            try {
                console.log('ðŸ”§ Creating staking contract...');
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                
                // Get contract details
                const [
                    stakingToken,
                    rewardToken,
                    totalStaked,
                    totalRewards,
                    contractEthBalance,
                    earlyWithdrawFee,
                    currentOwner
                ] = await Promise.all([
                    stakingContract.stakingToken(),
                    stakingContract.rewardToken(),
                    stakingContract.totalStaked(),
                    stakingContract.totalRewards(),
                    provider.getBalance(contractAddress),
                    stakingContract.earlyFee(), // Fixed: was earlyWithdrawFee()
                    stakingContract.owner()
                ]);

                // Check if user is owner
                if (currentOwner.toLowerCase() !== userAddress.toLowerCase()) {
                    showStatus('Only contract owner can withdraw fees', 'error');
                    return;
                }

                const isStakingEth = stakingToken === ethers.constants.AddressZero;
                const isRewardEth = rewardToken === ethers.constants.AddressZero;

                let stakingTokenBalance = ethers.BigNumber.from(0);
                let rewardTokenBalance = ethers.BigNumber.from(0);

                // Get token balances if not ETH
                if (!isStakingEth) {
                    const stakingTokenContract = new ethers.Contract(stakingToken, [
                        "function balanceOf(address owner) external view returns (uint256)",
                        "function symbol() external view returns (string)"
                    ], provider);
                    stakingTokenBalance = await stakingTokenContract.balanceOf(contractAddress);
                }

                if (!isRewardEth) {
                    const rewardTokenContract = new ethers.Contract(rewardToken, [
                        "function balanceOf(address owner) external view returns (uint256)",
                        "function symbol() external view returns (string)"
                    ], provider);
                    rewardTokenBalance = await rewardTokenContract.balanceOf(contractAddress);
                }

                // Calculate withdrawable amounts (ONLY fees and true excess)
                let withdrawableEth = ethers.BigNumber.from(0);
                let withdrawableStakingTokens = ethers.BigNumber.from(0);
                let withdrawableRewardTokens = ethers.BigNumber.from(0);

                // For ETH calculations
                if (isStakingEth && isRewardEth) {
                    // Both staking and rewards are ETH - subtract reserved amounts
                    const totalReservedEth = totalStaked.add(totalRewards);
                    withdrawableEth = contractEthBalance.gt(totalReservedEth) ? 
                        contractEthBalance.sub(totalReservedEth) : ethers.BigNumber.from(0);
                } else if (isStakingEth && !isRewardEth) {
                    // Staking is ETH, rewards are tokens
                    withdrawableEth = contractEthBalance.gt(totalStaked) ? 
                        contractEthBalance.sub(totalStaked) : ethers.BigNumber.from(0);
                    withdrawableRewardTokens = rewardTokenBalance.gt(totalRewards) ? 
                        rewardTokenBalance.sub(totalRewards) : ethers.BigNumber.from(0);
                } else if (!isStakingEth && isRewardEth) {
                    // Staking is tokens, rewards are ETH
                    withdrawableStakingTokens = stakingTokenBalance.gt(totalStaked) ? 
                        stakingTokenBalance.sub(totalStaked) : ethers.BigNumber.from(0);
                    withdrawableEth = contractEthBalance.gt(totalRewards) ? 
                        contractEthBalance.sub(totalRewards) : ethers.BigNumber.from(0);
                } else {
                    // Both are tokens - check if they're the same token
                    if (stakingToken.toLowerCase() === rewardToken.toLowerCase()) {
                        // Same token for staking and rewards - only calculate once
                        const totalReservedTokens = totalStaked.add(totalRewards);
                        withdrawableStakingTokens = stakingTokenBalance.gt(totalReservedTokens) ? 
                            stakingTokenBalance.sub(totalReservedTokens) : ethers.BigNumber.from(0);
                        withdrawableRewardTokens = ethers.BigNumber.from(0); // Don't double count
                    } else {
                        // Different tokens - calculate separately  
                        withdrawableStakingTokens = stakingTokenBalance.gt(totalStaked) ? 
                            stakingTokenBalance.sub(totalStaked) : ethers.BigNumber.from(0);
                        withdrawableRewardTokens = rewardTokenBalance.gt(totalRewards) ? 
                            rewardTokenBalance.sub(totalRewards) : ethers.BigNumber.from(0);
                    }
                    withdrawableEth = contractEthBalance; // Any ETH in contract is withdrawable
                }

                // Get token symbols
                let stakingTokenSymbol = 'ETH';
                let rewardTokenSymbol = 'ETH';

                if (!isStakingEth) {
                    try {
                        const stakingTokenContract = new ethers.Contract(stakingToken, [
                            "function symbol() external view returns (string)"
                        ], provider);
                        stakingTokenSymbol = await stakingTokenContract.symbol();
                    } catch (e) {
                        stakingTokenSymbol = 'TOKEN';
                    }
                }

                if (!isRewardEth) {
                    try {
                        const rewardTokenContract = new ethers.Contract(rewardToken, [
                            "function symbol() external view returns (string)"
                        ], provider);
                        rewardTokenSymbol = await rewardTokenContract.symbol();
                    } catch (e) {
                        rewardTokenSymbol = 'TOKEN';
                    }
                }

                // Populate modal with contract address
                document.getElementById('feesContractAddress').textContent = `${contractAddress.slice(0, 6)}...${contractAddress.slice(-4)}`;
                
                // Show available withdrawable amounts
                let availableWithdrawals = [];
                
                if (withdrawableEth.gt(0)) {
                    availableWithdrawals.push(`${ethers.utils.formatEther(withdrawableEth)} ETH`);
                }
                if (withdrawableStakingTokens.gt(0)) {
                    availableWithdrawals.push(`${ethers.utils.formatEther(withdrawableStakingTokens)} ${stakingTokenSymbol}`);
                }
                if (withdrawableRewardTokens.gt(0)) {
                    availableWithdrawals.push(`${ethers.utils.formatEther(withdrawableRewardTokens)} ${rewardTokenSymbol}`);
                }

                document.getElementById('availableWithdrawals').innerHTML = 
                    availableWithdrawals.length > 0 ? 
                    availableWithdrawals.map(amount => `<div class="mobile-amount">â€¢ ${amount}</div>`).join('') :
                    '<div style="color: var(--console-red);">No withdrawable fees available</div>';

                // Show modal
                console.log('ðŸ”§ Showing withdraw fees modal...');
                const modal = document.getElementById('withdrawFeesModal');
                console.log('ðŸ”§ Modal element found:', !!modal);
                if (modal) {
                    modal.style.display = 'flex';
                    console.log('âœ… Withdraw fees modal should now be visible');
                } else {
                    console.error('âŒ Withdraw fees modal element not found!');
                }

                // Handle form submission
                const form = document.getElementById('withdrawFeesForm');
                if (form) {
                    form.onsubmit = async (e) => {
                        e.preventDefault();
                        const tokenAddress = document.getElementById('feeTokenAddress').value;
                        const amount = document.getElementById('feeWithdrawAmount').value;
                        await executeWithdrawFees(contractAddress, tokenAddress, amount, {
                            withdrawableEth,
                            withdrawableStakingTokens,
                            withdrawableRewardTokens,
                            stakingToken,
                            rewardToken,
                            stakingTokenSymbol,
                            rewardTokenSymbol
                        });
                        closeAdminModal('withdrawFeesModal');
                    };
                }

            } catch (error) {
                console.error('âŒ Error opening withdraw fees modal:', error);
                console.error('âŒ Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                showStatus('Error opening withdraw fees modal: ' + error.message, 'error');
            }
        }

        // Execute withdraw fees (only allows withdrawal of actual fees/excess)
        async function executeWithdrawFees(contractAddress, tokenAddress, amount, withdrawableAmounts) {
            if (!amount || parseFloat(amount) <= 0) {
                showStatus('Invalid amount entered', 'error');
                return;
            }

            try {
                const amountWei = ethers.utils.parseEther(amount);
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);

                // Determine what token is being withdrawn and validate amount
                const isEth = tokenAddress === '0x0' || tokenAddress.toLowerCase() === 'eth';
                const isStakingToken = tokenAddress.toLowerCase() === withdrawableAmounts.stakingToken.toLowerCase();
                const isRewardToken = tokenAddress.toLowerCase() === withdrawableAmounts.rewardToken.toLowerCase();

                let maxWithdrawable, tokenSymbol;

                if (isEth) {
                    maxWithdrawable = withdrawableAmounts.withdrawableEth;
                    tokenSymbol = 'ETH';
                } else if (isStakingToken) {
                    maxWithdrawable = withdrawableAmounts.withdrawableStakingTokens;
                    tokenSymbol = withdrawableAmounts.stakingTokenSymbol;
                } else if (isRewardToken) {
                    maxWithdrawable = withdrawableAmounts.withdrawableRewardTokens;
                    tokenSymbol = withdrawableAmounts.rewardTokenSymbol;
                } else {
                    showStatus('Invalid token address', 'error');
                    return;
                }

                if (amountWei.gt(maxWithdrawable)) {
                    showStatus(`Amount exceeds withdrawable fees/rewards. Max: ${ethers.utils.formatEther(maxWithdrawable)} ${tokenSymbol}`, 'error');
                    return;
                }

                const finalTokenAddress = isEth ? ethers.constants.AddressZero : tokenAddress;

                const tx = await stakingContract.withdrawExcess(finalTokenAddress, amountWei, {
                    gasLimit: 200000
                });

                showStatus('Withdrawing fees/rewards...', 'warning');
                await tx.wait();
                showStatus(`Successfully withdrew ${amount} ${tokenSymbol} in fees/rewards!`, 'success');

            } catch (error) {
                console.error('Error withdrawing fees:', error);
                showStatus('Failed to withdraw fees/rewards: ' + error.message, 'error');
            }
        }

        // Open transfer ownership modal
        async function openTransferOwnershipModal(contractAddress) {
            console.log('ðŸ”§ openTransferOwnershipModal called with:', { contractAddress });
            console.log('ðŸ”§ Signer available:', !!signer);
            
            if (!signer) {
                console.error('âŒ No signer available');
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            try {
                console.log('ðŸ”§ Creating staking contract...');
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                const currentOwner = await stakingContract.owner();

                // Populate modal
                document.getElementById('ownershipContractAddress').textContent = contractAddress;
                document.getElementById('currentOwner').textContent = currentOwner;

                // Show modal
                document.getElementById('transferOwnershipModal').style.display = 'flex';

                // Handle form submission
                const form = document.getElementById('transferOwnershipForm');
                form.onsubmit = async (e) => {
                    e.preventDefault();
                    const newOwnerAddress = document.getElementById('newOwnerAddress').value;
                    await executeTransferOwnership(contractAddress, newOwnerAddress);
                    closeAdminModal('transferOwnershipModal');
                };

            } catch (error) {
                console.error('Error opening ownership modal:', error);
                showStatus('Failed to load ownership modal: ' + error.message, 'error');
            }
        }

        // Execute transfer ownership
        async function executeTransferOwnership(contractAddress, newOwnerAddress) {
            if (!ethers.utils.isAddress(newOwnerAddress)) {
                showStatus('Invalid wallet address format', 'error');
                return;
            }

            try {
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                const tx = await stakingContract.transferOwnership(newOwnerAddress, {
                    gasLimit: 100000
                });

                showStatus('Transferring ownership...', 'warning');
                await tx.wait();
                showStatus(`Ownership successfully transferred to ${newOwnerAddress}!`, 'success');

                setTimeout(() => loadContractsDirectory(), 2000);

            } catch (error) {
                console.error('Error transferring ownership:', error);
                showStatus('Failed to transfer ownership: ' + error.message, 'error');
            }
        }

        // Open emergency withdraw modal
        async function openEmergencyWithdrawModal(contractAddress) {
            if (!signer) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            try {
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                const totalStaked = await stakingContract.totalStaked();

                // Populate modal
                document.getElementById('emergencyContractAddress').textContent = contractAddress;
                document.getElementById('emergencyTotalStaked').textContent = `${ethers.utils.formatEther(totalStaked)} tokens`;

                // Show modal
                document.getElementById('emergencyWithdrawModal').style.display = 'flex';

            } catch (error) {
                console.error('Error opening emergency modal:', error);
                showStatus('Failed to load emergency modal: ' + error.message, 'error');
            }
        }

        // Execute emergency withdraw
        async function confirmEmergencyWithdraw() {
            const contractAddress = document.getElementById('emergencyContractAddress').textContent;
            
            try {
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                const tx = await stakingContract.enableEmergencyWithdraw({
                    gasLimit: 100000
                });

                showStatus('Enabling emergency withdraw...', 'warning');
                await tx.wait();
                showStatus('Emergency withdraw enabled successfully!', 'success');

                closeAdminModal('emergencyWithdrawModal');
                setTimeout(() => loadContractsDirectory(), 2000);

            } catch (error) {
                console.error('Error enabling emergency withdraw:', error);
                showStatus('Failed to enable emergency withdraw: ' + error.message, 'error');
            }
        }

        // Admin Functions for Contract Creators

        // Deposit rewards into a staking contract
        async function depositRewards(contractAddress, rewardTokenSymbol) {
            console.log('ðŸ”§ Admin Control: depositRewards called', { contractAddress, rewardTokenSymbol });
            
            if (!signer) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            try {
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                const rewardToken = await stakingContract.rewardToken();
                const isEthReward = rewardToken === ethers.constants.AddressZero;

                // Simple prompt first, then get balances
                const amount = prompt(`Enter amount of ${rewardTokenSymbol} to deposit as rewards:`);
                if (!amount || parseFloat(amount) <= 0) {
                    showStatus('Invalid amount entered', 'error');
                    return;
                }

                const amountWei = ethers.utils.parseEther(amount);

                // Get user balance and contract info for confirmation
                let userBalance, contractRewardBalance, totalRewardsDistributed;
                
                try {
                    if (isEthReward) {
                        // ETH balances
                        userBalance = await signer.getBalance();
                        contractRewardBalance = await provider.getBalance(contractAddress);
                    } else {
                        // Token balances
                        const tokenContract = new ethers.Contract(rewardToken, ERC20_ABI, provider);
                        userBalance = await tokenContract.balanceOf(userAddress);
                        contractRewardBalance = await tokenContract.balanceOf(contractAddress);
                    }
                    
                    totalRewardsDistributed = await stakingContract.totalRewards();

                    const userBalanceFormatted = ethers.utils.formatEther(userBalance);
                    const contractBalanceFormatted = ethers.utils.formatEther(contractRewardBalance);
                    const totalRewardsFormatted = ethers.utils.formatEther(totalRewardsDistributed);

                    const amountFloat = parseFloat(amount);
                    const userBalanceFloat = parseFloat(userBalanceFormatted);

                    // Check if user has enough balance
                    if (amountFloat > userBalanceFloat) {
                        showStatus(`Insufficient balance. You have ${userBalanceFormatted} ${rewardTokenSymbol}`, 'error');
                        return;
                    }

                    const confirmMessage = `
CONFIRM REWARD DEPOSIT:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â€¢ Amount to Deposit: ${amount} ${rewardTokenSymbol}
â€¢ Your Balance: ${userBalanceFormatted} ${rewardTokenSymbol}
â€¢ Contract Current Balance: ${contractBalanceFormatted} ${rewardTokenSymbol}
â€¢ Total Rewards Distributed: ${totalRewardsFormatted} ${rewardTokenSymbol}
â€¢ Contract: ${contractAddress}
â€¢ Type: ${isEthReward ? 'ETH Rewards' : 'Token Rewards'}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Deposit these rewards?`;
                    
                    if (!confirm(confirmMessage)) {
                        showStatus('Reward deposit cancelled by user', 'warning');
                        return;
                    }
                } catch (balanceError) {
                    console.warn('Could not get balance info:', balanceError);
                    // Continue without balance check
                    const simpleConfirm = `
DEPOSIT REWARDS:
â€¢ Amount: ${amount} ${rewardTokenSymbol}
â€¢ Contract: ${contractAddress}
â€¢ Type: ${isEthReward ? 'ETH Rewards' : 'Token Rewards'}

Deposit these rewards?`;
                    
                    if (!confirm(simpleConfirm)) {
                        showStatus('Reward deposit cancelled by user', 'warning');
                        return;
                    }
                }

                let tx;
                if (isEthReward) {
                    // For ETH rewards, amount parameter should be 0 and ETH sent via value
                    console.log('Sending ETH reward deposit:', { value: amountWei.toString() });
                    tx = await stakingContract.depositRewards(0, { 
                        value: amountWei,
                        gasLimit: 300000
                    });
                } else {
                    // For token rewards, user must approve tokens first
                    console.log('Token reward deposit detected. Checking allowance...');
                    
                    const tokenContract = new ethers.Contract(rewardToken, [
                        "function approve(address spender, uint256 amount) external returns (bool)",
                        "function allowance(address owner, address spender) external view returns (uint256)"
                    ], signer);
                    
                    // Check current allowance
                    const currentAllowance = await tokenContract.allowance(userAddress, contractAddress);
                    console.log('Current allowance:', ethers.utils.formatEther(currentAllowance));
                    
                    if (currentAllowance.lt(amountWei)) {
                        console.log('Insufficient allowance, requesting approval...');
                        showStatus('Approving tokens... Please confirm the approval transaction first.', 'warning');
                        
                        const approveTx = await tokenContract.approve(contractAddress, amountWei);
                        console.log('Approval transaction submitted:', approveTx.hash);
                        showStatus('Waiting for approval confirmation...', 'warning');
                        await approveTx.wait();
                        console.log('Approval confirmed');
                        showStatus('Approval confirmed. Now depositing rewards...', 'warning');
                    }
                    
                    console.log('Sending token reward deposit:', { amount: amountWei.toString() });
                    tx = await stakingContract.depositRewards(amountWei, {
                        gasLimit: 300000
                    });
                }

                console.log('Transaction submitted:', tx);
                showStatus('Depositing rewards...', 'warning');
                const receipt = await tx.wait();
                console.log('Transaction confirmed:', receipt);
                
                showStatus(`Successfully deposited ${amount} ${rewardTokenSymbol} as rewards!`, 'success');
                
                // Refresh contracts directory
                setTimeout(() => loadContractsDirectory(), 2000);

            } catch (error) {
                console.error('Error depositing rewards:', error);
                showStatus('Failed to deposit rewards: ' + error.message, 'error');
            }
        }

        // Enable emergency withdraw
        async function enableEmergencyWithdraw(contractAddress) {
            console.log('ðŸ”§ Admin Control: enableEmergencyWithdraw called', { contractAddress });
            
            if (!signer) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            const confirmMessage = `
                ENABLE EMERGENCY WITHDRAW:
                This will allow all users to withdraw their tokens without early fees.
                This action cannot be reversed.
                
                Continue?
            `;
            
            if (!confirm(confirmMessage)) {
                return;
            }

            try {
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                const tx = await stakingContract.enableEmergencyWithdraw({
                    gasLimit: 100000
                });

                showStatus('Enabling emergency withdraw...', 'warning');
                await tx.wait();
                showStatus('Emergency withdraw enabled successfully!', 'success');

            } catch (error) {
                console.error('Error enabling emergency withdraw:', error);
                showStatus('Failed to enable emergency withdraw: ' + error.message, 'error');
            }
        }

        // Withdraw excess tokens
        async function withdrawExcess(contractAddress) {
            console.log('ðŸ”§ Admin Control: withdrawExcess called', { contractAddress });
            
            if (!signer) {
                showStatus('Please connect your wallet first', 'error');
                return;
            }

            try {
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);
                const stakingToken = await stakingContract.stakingToken();
                const rewardToken = await stakingContract.rewardToken();
                const totalStaked = await stakingContract.totalStaked();
                const totalRewards = await stakingContract.totalRewards();
                
                // Get contract balances
                const contractEthBalance = await provider.getBalance(contractAddress);
                
                let stakingTokenBalance = ethers.BigNumber.from(0);
                let rewardTokenBalance = ethers.BigNumber.from(0);
                
                const isStakingEth = stakingToken === ethers.constants.AddressZero;
                const isRewardEth = rewardToken === ethers.constants.AddressZero;
                
                if (!isStakingEth) {
                    const stakingTokenContract = new ethers.Contract(stakingToken, ERC20_ABI, provider);
                    stakingTokenBalance = await stakingTokenContract.balanceOf(contractAddress);
                }
                
                if (!isRewardEth) {
                    const rewardTokenContract = new ethers.Contract(rewardToken, ERC20_ABI, provider);
                    rewardTokenBalance = await rewardTokenContract.balanceOf(contractAddress);
                }

                // Calculate excess amounts (what can be withdrawn)
                const stakingExcess = isStakingEth ? 
                    contractEthBalance.sub(totalStaked) : 
                    stakingTokenBalance.sub(totalStaked);
                    
                const rewardExcess = isRewardEth ? 
                    contractEthBalance.sub(totalRewards) : 
                    rewardTokenBalance.sub(totalRewards);

                const balanceInfo = `
WITHDRAW EXCESS - CONTRACT BALANCES:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ðŸ“Š CONTRACT ETH BALANCE: ${ethers.utils.formatEther(contractEthBalance)} ETH

ðŸ”¹ STAKING TOKEN (${isStakingEth ? 'ETH' : 'TOKEN'}):
   â€¢ Total Staked: ${ethers.utils.formatEther(totalStaked)}
   â€¢ Contract Balance: ${ethers.utils.formatEther(isStakingEth ? contractEthBalance : stakingTokenBalance)}
   â€¢ EXCESS AVAILABLE: ${ethers.utils.formatEther(stakingExcess.gt(0) ? stakingExcess : 0)}

ðŸ”¸ REWARD TOKEN (${isRewardEth ? 'ETH' : 'TOKEN'}):
   â€¢ Total Rewards: ${ethers.utils.formatEther(totalRewards)}
   â€¢ Contract Balance: ${ethers.utils.formatEther(isRewardEth ? contractEthBalance : rewardTokenBalance)}
   â€¢ EXCESS AVAILABLE: ${ethers.utils.formatEther(rewardExcess.gt(0) ? rewardExcess : 0)}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Options:
â€¢ ETH: Enter "0x0"
â€¢ Staking Token: Enter "${stakingToken}"
â€¢ Reward Token: Enter "${rewardToken}"
â€¢ Other Token: Enter token address

Enter token address to withdraw:`;

                const tokenAddress = prompt(balanceInfo);
                if (!tokenAddress) return;

                // Determine token type and available excess
                let maxWithdrawable, tokenSymbol;
                const isEth = tokenAddress === '0x0';
                const isStakingTokenWithdraw = tokenAddress.toLowerCase() === stakingToken.toLowerCase();
                const isRewardTokenWithdraw = tokenAddress.toLowerCase() === rewardToken.toLowerCase();

                if (isEth) {
                    // For ETH, need to consider both staking and reward reserves
                    const totalReserved = totalStaked.add(totalRewards);
                    maxWithdrawable = contractEthBalance.sub(totalReserved);
                    tokenSymbol = 'ETH';
                } else if (isStakingTokenWithdraw) {
                    maxWithdrawable = stakingExcess;
                    tokenSymbol = 'STAKING TOKENS';
                } else if (isRewardTokenWithdraw) {
                    maxWithdrawable = rewardExcess;
                    tokenSymbol = 'REWARD TOKENS';
                } else {
                    // Other token - can withdraw full balance
                    try {
                        const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                        maxWithdrawable = await tokenContract.balanceOf(contractAddress);
                        tokenSymbol = 'TOKENS';
                    } catch (err) {
                        showStatus('Invalid token address', 'error');
                        return;
                    }
                }

                if (maxWithdrawable.lte(0)) {
                    showStatus(`No excess ${tokenSymbol} available to withdraw`, 'error');
                    return;
                }

                const maxWithdrawableFormatted = ethers.utils.formatEther(maxWithdrawable);

                const amountPrompt = `
AVAILABLE TO WITHDRAW: ${maxWithdrawableFormatted} ${tokenSymbol}

Enter amount to withdraw (max: ${maxWithdrawableFormatted}):`;

                const amount = prompt(amountPrompt);
                if (!amount || parseFloat(amount) <= 0) {
                    showStatus('Invalid amount entered', 'error');
                    return;
                }

                const amountWei = ethers.utils.parseEther(amount);
                
                // Check if amount exceeds available
                if (amountWei.gt(maxWithdrawable)) {
                    showStatus(`Amount exceeds available excess. Max: ${maxWithdrawableFormatted} ${tokenSymbol}`, 'error');
                    return;
                }

                const finalTokenAddress = isEth ? ethers.constants.AddressZero : tokenAddress;

                const confirmMessage = `
CONFIRM EXCESS WITHDRAWAL:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â€¢ Token: ${isEth ? 'ETH' : tokenAddress}
â€¢ Amount: ${amount} ${tokenSymbol}
â€¢ Max Available: ${maxWithdrawableFormatted} ${tokenSymbol}
â€¢ Remaining After: ${(parseFloat(maxWithdrawableFormatted) - parseFloat(amount)).toFixed(6)} ${tokenSymbol}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸  This withdraws excess tokens not used for staking/rewards

Continue with withdrawal?
                `;
                
                if (!confirm(confirmMessage)) {
                    showStatus('Withdrawal cancelled by user', 'warning');
                    return;
                }

                const tx = await stakingContract.withdrawExcess(finalTokenAddress, amountWei, {
                    gasLimit: 200000
                });

                showStatus('Withdrawing excess tokens...', 'warning');
                await tx.wait();
                showStatus(`Successfully withdrew ${amount} ${tokenSymbol}!`, 'success');

            } catch (error) {
                console.error('Error withdrawing excess:', error);
                showStatus('Failed to withdraw excess: ' + error.message, 'error');
            }
        }

        // Transfer Ownership function
        async function transferOwnership(contractAddress) {
            try {
                if (!signer) {
                    throw new Error('Please connect your wallet first');
                }

                console.log('ðŸ”§ Admin Control: transferOwnership called', { contractAddress });

                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, signer);

                // Verify the caller is the current owner
                const currentOwner = await stakingContract.owner();
                if (currentOwner.toLowerCase() !== userAddress.toLowerCase()) {
                    throw new Error('Only the contract owner can transfer ownership');
                }

                const newOwnerAddress = prompt(`
TRANSFER OWNERSHIP:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸  WARNING: This action cannot be undone!

Current Owner: ${currentOwner}
Contract: ${contractAddress}

You are about to transfer ownership of this staking contract.
The new owner will have full control over:
â€¢ Depositing rewards
â€¢ Emergency withdraw functions
â€¢ Withdrawing excess tokens
â€¢ All other admin functions

Enter the new owner's wallet address:`);

                if (!newOwnerAddress) {
                    showStatus('Ownership transfer cancelled by user', 'warning');
                    return;
                }

                // Basic address validation
                if (!ethers.utils.isAddress(newOwnerAddress)) {
                    throw new Error('Invalid wallet address format');
                }

                // Prevent transferring to the same address
                if (newOwnerAddress.toLowerCase() === currentOwner.toLowerCase()) {
                    throw new Error('Cannot transfer ownership to the same address');
                }

                const confirmMessage = `
CONFIRM OWNERSHIP TRANSFER:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸  FINAL WARNING: This action is IRREVERSIBLE!

â€¢ Current Owner: ${currentOwner}
â€¢ New Owner: ${newOwnerAddress}
â€¢ Contract: ${contractAddress}

After this transfer:
âœ“ The new owner will have full admin control
âœ“ You will lose all admin privileges
âœ“ This action cannot be undone

Are you absolutely sure you want to proceed?`;

                if (!confirm(confirmMessage)) {
                    showStatus('Ownership transfer cancelled by user', 'warning');
                    return;
                }

                showStatus('Transferring ownership...', 'warning');

                const tx = await stakingContract.transferOwnership(newOwnerAddress, {
                    gasLimit: 100000
                });

                await tx.wait();

                showStatus(`Ownership successfully transferred to ${newOwnerAddress}!`, 'success');
                
                // Refresh the contracts to update admin controls visibility
                setTimeout(() => {
                    refreshDirectory();
                }, 2000);

            } catch (error) {
                console.error('Error transferring ownership:', error);
                showStatus('Failed to transfer ownership: ' + error.message, 'error');
            }
        }

        // Verify contract on Basescan
        async function verifyContract(contractAddress, constructorArgs) {
            try {
                showStatus('Attempting to verify contract on Basescan...', 'warning');

                const sourceCode = `// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

// Your complete flattened source code would go here
// This would include all the contracts you provided in your original message
`;

                const verificationData = {
                    apikey: CONFIG.BASESCAN_API_KEY,
                    module: 'contract',
                    action: 'verifysourcecode',
                    contractaddress: contractAddress,
                    sourceCode: sourceCode,
                    codeformat: 'solidity-single-file',
                    contractname: 'StakingContract',
                    compilerversion: 'v0.8.19+commit.7dd6d404',
                    optimizationUsed: '1',
                    runs: '200',
                    constructorArguements: '' // Would need to encode constructor arguments
                };

                // Note: In a real implementation, you'd need to properly encode the constructor arguments
                // and include the complete source code
                showStatus('Contract verification submitted to Basescan (implementation pending)', 'warning');

            } catch (error) {
                console.error('Error verifying contract:', error);
                showStatus('Contract verification failed', 'error');
            }
        }

        // Show status message
        function showStatus(message, type = 'info') {
            const statusElement = document.getElementById('deployStatus');
            statusElement.innerHTML = `<div class="status-message status-${type}">${message}</div>`;
            
            // Auto-hide success messages
            if (type === 'success') {
                setTimeout(() => {
                    statusElement.innerHTML = '';
                }, 5000);
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('stakingModal');
            if (event.target === modal) {
                closeModal();
            }
        };

        // View contract on Basescan
        function viewOnBasescan(contractAddress) {
            const url = `https://basescan.org/address/${contractAddress}`;
            window.open(url, '_blank');
        }

        // Make functions globally available
        window.openStakingModal = openStakingModal;
        window.closeModal = closeModal;
        window.viewOnBasescan = viewOnBasescan;
        window.getAllCurrentContractsForBlacklist = getAllCurrentContractsForBlacklist;
        window.performStake = performStake;
        window.performWithdraw = performWithdraw;
        window.claimRewards = claimRewards;
        window.executeWithdrawal = executeWithdrawal;
        window.executeClaimRewards = executeClaimRewards;
        window.executeStake = executeStake;
        window.copyToClipboard = copyToClipboard;
        
        // New modal-based admin functions (Coinbase Wallet compatible)
        window.openDepositRewardsModal = openDepositRewardsModal;
        window.openWithdrawFeesModal = openWithdrawFeesModal;
        window.openTransferOwnershipModal = openTransferOwnershipModal;
        window.openEmergencyWithdrawModal = openEmergencyWithdrawModal;
        window.closeAdminModal = closeAdminModal;
        window.confirmEmergencyWithdraw = confirmEmergencyWithdraw;
        
        // Legacy admin functions (still available for compatibility)
        window.depositRewards = depositRewards;
        window.enableEmergencyWithdraw = enableEmergencyWithdraw;
        window.withdrawExcess = withdrawExcess;
        window.transferOwnership = transferOwnership;
        
        // Global variables for filtering
        let allContracts = [];
        let filteredContracts = [];
        
        // Search and Filter Functions
        async function searchContracts() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
            
            if (searchTerm === '') {
                // Show all contracts if search is empty
                displayContracts(allContracts);
                updateResultsCount(allContracts.length);
                return;
            }
            
            // Filter contracts based on search term
            const filteredContracts = allContracts.filter(contract => {
                const contractData = contract.searchData;
                return contractData.name.includes(searchTerm) ||
                    contractData.stakingSymbol.includes(searchTerm) ||
                    contractData.rewardSymbol.includes(searchTerm) ||
                    contractData.contractAddress.includes(searchTerm) ||
                    contractData.apy.toString().includes(searchTerm);
            });
            
            displayContracts(filteredContracts);
            updateResultsCount(filteredContracts.length);
        }

        async function filterContracts() {
            // For backward compatibility, just call searchContracts
            await searchContracts();
        }

        function clearFilters() {
            // Clear search input and show all contracts
            document.getElementById('searchInput').value = '';
            displayContracts(allContracts);
            updateResultsCount(allContracts.length);
        }

        function displayContracts(contracts) {
            renderContracts(contracts);
        }

        function updateResultsCount(count) {
            document.getElementById('resultsCount').textContent = 
                `Showing ${count} of ${allContracts.length} contracts`;
        }

        async function renderContracts(contractsToRender) {
            const contractsContainer = document.getElementById('contractsContainer');
            
            if (contractsToRender.length === 0) {
                contractsContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--secondary-text);">
                        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="opacity: 0.5; margin-bottom: 16px;">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                        <h3>No contracts found</h3>
                        <p>Try adjusting your search criteria</p>
                    </div>
                `;
                return;
            }
            
            let html = '<div class="contracts-grid">';
            for (const contractData of contractsToRender) {
                const cardHtml = await createContractCard(contractData.contract || contractData);
                html += cardHtml;
            }
            html += '</div>';
            
            contractsContainer.innerHTML = html;
        }
        
        function clearFilters() {
            document.getElementById('searchInput').value = '';
            document.getElementById('sortFilter').value = 'newest';
            document.getElementById('tokenFilter').value = 'all';
            document.getElementById('apyFilter').value = 'all';
            filterContracts();
        }
        
        function refreshDirectory() {
            loadContractsDirectory();
        }
        
        // Enhanced contract loading with search data
        async function loadContractsDirectoryWithSearch() {
            try {
                const contractsContainer = document.getElementById('contractsContainer');
                contractsContainer.innerHTML = '<div class="loading"><div class="spinner"></div></div>';

                // Check if factoryContract is initialized
                if (!factoryContract) {
                    contractsContainer.innerHTML = '<p style="text-align: center; color: var(--secondary-text);">Please connect your wallet to view contracts.</p>';
                    return;
                }

                const count = await factoryContract.getDeployedContractsCount();
                console.log(`ðŸ“Š Total contracts in factory: ${count.toNumber()}`);
                
                if (count.eq(0)) {
                    contractsContainer.innerHTML = '<p style="text-align: center; color: var(--secondary-text);">No contracts deployed yet.</p>';
                    return;
                }

                allContracts = [];
                for (let i = 0; i < count.toNumber(); i++) {
                    const info = await factoryContract.getContractInfo(i);
                    const deploymentTime = info.createdAt ? info.createdAt.toNumber() : 0;
                    const isBlacklisted = deploymentTime < BLACKLIST_BEFORE_TIMESTAMP;
                    
                    // Only include contracts that are not blacklisted
                    if (!isBlacklisted) {
                        // Get additional data for search
                        const stakingTokenInfo = await getTokenInfo(info.stakingToken);
                        const rewardTokenInfo = await getTokenInfo(info.rewardToken);
                        
                        // Get TVL
                        let tvl = 0;
                        try {
                            const stakingContract = new ethers.Contract(info.contractAddress, STAKING_ABI, provider);
                            const totalStaked = await stakingContract.totalStaked();
                            tvl = parseFloat(ethers.utils.formatEther(totalStaked));
                        } catch (err) {
                            console.warn(`Could not get TVL for ${info.name}:`, err.message);
                        }
                        
                        const contractData = {
                            contract: info,
                            searchData: {
                                name: info.name.toLowerCase(),
                                stakingSymbol: stakingTokenInfo.symbol.toLowerCase(),
                                rewardSymbol: rewardTokenInfo.symbol.toLowerCase(),
                                contractAddress: info.contractAddress.toLowerCase(),
                                creator: info.creator.toLowerCase(),
                                apy: info.apy.toNumber() / 100,
                                tvl: tvl,
                                isEthStaking: info.stakingToken === ethers.constants.AddressZero,
                                isEthReward: info.rewardToken === ethers.constants.AddressZero
                            }
                        };
                        
                        allContracts.push(contractData);
                        console.log(`âœ… Contract ${i} (${info.name}) added to display`);
                    }
                }

                console.log(`ðŸ“‹ Contracts to display: ${allContracts.length}`);

                // Check if all contracts are blacklisted
                if (allContracts.length === 0) {
                    contractsContainer.innerHTML = '<p style="text-align: center; color: var(--secondary-text);">No active contracts to display.</p>';
                    return;
                }

                // Initialize and display contracts
                displayContracts(allContracts);
                updateResultsCount(allContracts.length);

            } catch (error) {
                console.error('Error loading contracts:', error);
                const contractsContainer = document.getElementById('contractsContainer');
                if (!factoryContract) {
                    contractsContainer.innerHTML = '<p style="text-align: center; color: var(--warning-color);">Please connect your wallet to view contracts.</p>';
                } else {
                    contractsContainer.innerHTML = '<p style="color: var(--error-color);">Error loading contracts: ' + error.message + '</p>';
                }
            }
        }
        
        // Update the original function to use the new search version
        window.loadContractsDirectory = loadContractsDirectoryWithSearch;
        
        // Time Period Verification Functions
        async function verifyTimePeriods(contractAddress) {
            if (!provider) {
                showStatus('Please connect wallet first', 'error');
                return;
            }

            try {
                console.log('ðŸ• Verifying time periods for contract:', contractAddress);
                
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, provider);
                
                // Get contract parameters
                const lockPeriod = await stakingContract.lockPeriod();
                const earlyFee = await stakingContract.earlyFee();
                
                console.log('ðŸ“Š Contract Time Settings:');
                console.log(`  Lock Period (seconds): ${lockPeriod.toString()}`);
                console.log(`  Lock Period (days): ${lockPeriod.toNumber() / 86400}`);
                console.log(`  Early Fee (%): ${earlyFee.toNumber() / 100}`);
                
                // Calculate time conversions
                const lockPeriodDays = lockPeriod.toNumber() / 86400;
                const lockPeriodHours = lockPeriod.toNumber() / 3600;
                const lockPeriodMinutes = lockPeriod.toNumber() / 60;
                
                console.log('ðŸ§® Time Conversions:');
                console.log(`  ${lockPeriod.toNumber()} seconds`);
                console.log(`  ${lockPeriodMinutes} minutes`);
                console.log(`  ${lockPeriodHours} hours`);
                console.log(`  ${lockPeriodDays} days`);
                
                // Test if user has staked
                if (signer) {
                    const userAddress = await signer.getAddress();
                    const userStake = await stakingContract.userStakes(userAddress);
                    const stakeTimestamp = await stakingContract.getStakeTimestamp(userAddress);
                    
                    if (userStake.gt(0) && stakeTimestamp.gt(0)) {
                        const currentTime = Math.floor(Date.now() / 1000);
                        const stakeTime = stakeTimestamp.toNumber();
                        const timePassed = currentTime - stakeTime;
                        const unlockTime = stakeTime + lockPeriod.toNumber();
                        const timeRemaining = unlockTime - currentTime;
                        
                        console.log('â° User Stake Timing:');
                        console.log(`  Stake Time: ${new Date(stakeTime * 1000).toLocaleString()}`);
                        console.log(`  Current Time: ${new Date(currentTime * 1000).toLocaleString()}`);
                        console.log(`  Unlock Time: ${new Date(unlockTime * 1000).toLocaleString()}`);
                        console.log(`  Time Passed: ${Math.floor(timePassed / 86400)} days, ${Math.floor((timePassed % 86400) / 3600)} hours`);
                        console.log(`  Time Remaining: ${Math.floor(timeRemaining / 86400)} days, ${Math.floor((timeRemaining % 86400) / 3600)} hours`);
                        
                        const canWithdrawWithoutFee = await stakingContract.canWithdrawWithoutFee(userAddress);
                        console.log(`  Can Withdraw Without Fee: ${canWithdrawWithoutFee}`);
                        
                        return {
                            lockPeriodSeconds: lockPeriod.toNumber(),
                            lockPeriodDays: lockPeriodDays,
                            stakeTime,
                            currentTime,
                            unlockTime,
                            timePassedSeconds: timePassed,
                            timeRemainingSeconds: timeRemaining,
                            canWithdrawWithoutFee,
                            earlyFeePercent: earlyFee.toNumber() / 100
                        };
                    } else {
                        console.log('âŒ User has no stake in this contract');
                        return {
                            lockPeriodSeconds: lockPeriod.toNumber(),
                            lockPeriodDays: lockPeriodDays,
                            earlyFeePercent: earlyFee.toNumber() / 100,
                            hasStake: false
                        };
                    }
                } else {
                    return {
                        lockPeriodSeconds: lockPeriod.toNumber(),
                        lockPeriodDays: lockPeriodDays,
                        earlyFeePercent: earlyFee.toNumber() / 100,
                        walletNotConnected: true
                    };
                }
                
            } catch (error) {
                console.error('âŒ Error verifying time periods:', error);
                showStatus('Error verifying time periods: ' + error.message, 'error');
                return null;
            }
        }
        
        // Test time period accuracy with a simple 1-day contract
        async function testOneDayPeriod() {
            console.log('ðŸ§ª Testing 1-day time period accuracy...');
            
            // 1 day = 86400 seconds
            const oneDayInSeconds = 86400;
            console.log(`1 day should equal ${oneDayInSeconds} seconds`);
            
            // Test the conversion used in contract creation
            const testDays = 1;
            const convertedSeconds = testDays * 86400;
            console.log(`Frontend conversion: ${testDays} day(s) = ${convertedSeconds} seconds`);
            
            // Test reverse conversion
            const backToDays = convertedSeconds / 86400;
            console.log(`Reverse conversion: ${convertedSeconds} seconds = ${backToDays} days`);
            
            console.log('âœ… Time conversion is mathematically correct');
            
            return {
                inputDays: testDays,
                calculatedSeconds: convertedSeconds,
                backToDays: backToDays,
                isAccurate: backToDays === testDays
            };
        }
        
        // Helper function to verify contract time periods from input
        async function verifyContractTimePeriods() {
            const contractAddress = document.getElementById('contractAddressToVerify')?.value?.trim();
            if (!contractAddress) {
                showStatus('Please enter a contract address to verify', 'warning');
                return;
            }
            
            if (!ethers.utils.isAddress(contractAddress)) {
                showStatus('Invalid contract address', 'error');
                return;
            }
            
            console.log('ðŸ” Verifying time periods for contract:', contractAddress);
            const result = await verifyTimePeriods(contractAddress);
            
            if (result) {
                let message = `Contract Time Verification Complete!\n\n`;
                message += `Lock Period: ${result.lockPeriodDays} days (${result.lockPeriodSeconds} seconds)\n`;
                message += `Early Fee: ${result.earlyFeePercent}%\n\n`;
                
                if (result.hasStake === false) {
                    message += `You have no stake in this contract.`;
                } else if (result.walletNotConnected) {
                    message += `Connect wallet to see your stake timing.`;
                } else if (result.canWithdrawWithoutFee !== undefined) {
                    message += `Your stake timing:\n`;
                    message += `- Time passed: ${Math.floor(result.timePassedSeconds / 86400)} days\n`;
                    message += `- Time remaining: ${Math.floor(result.timeRemainingSeconds / 86400)} days\n`;
                    message += `- Can withdraw without fee: ${result.canWithdrawWithoutFee ? 'YES âœ…' : 'NO âŒ'}`;
                }
                
                showStatus('Time verification complete - check console for details', 'success');
                alert(message);
            }
        }
        
        // Verify APY reward calculations
        async function verifyAPYCalculation(contractAddress, userAddress = null) {
            if (!provider) {
                showStatus('Please connect wallet first', 'error');
                return;
            }

            try {
                console.log('ðŸ’° Verifying APY calculations for contract:', contractAddress);
                
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, provider);
                
                // Get contract APY
                const contractAPY = await stakingContract.apy();
                const apyPercent = contractAPY.toNumber() / 100; // Convert from basis points
                
                console.log('ðŸ“Š Contract APY Settings:');
                console.log(`  APY (basis points): ${contractAPY.toString()}`);
                console.log(`  APY (percentage): ${apyPercent}%`);
                
                // Calculate expected daily rate
                const dailyRate = apyPercent / 365 / 100; // APY to daily rate
                const hourlyRate = dailyRate / 24;
                
                console.log('â° Time-based Rates:');
                console.log(`  Daily Rate: ${(dailyRate * 100).toFixed(8)}% per day`);
                console.log(`  Hourly Rate: ${(hourlyRate * 100).toFixed(10)}% per hour`);
                
                // If user address provided or wallet connected, get user data
                const targetAddress = userAddress || (signer ? await signer.getAddress() : null);
                
                if (targetAddress) {
                    const userStake = await stakingContract.userStakes(targetAddress);
                    const stakeTimestamp = await stakingContract.getStakeTimestamp(targetAddress);
                    const pendingRewards = await stakingContract.getPendingRewards(targetAddress);
                    
                    if (userStake.gt(0) && stakeTimestamp.gt(0)) {
                        const stakeAmount = parseFloat(ethers.utils.formatEther(userStake));
                        const rewardAmount = parseFloat(ethers.utils.formatEther(pendingRewards));
                        
                        const currentTime = Math.floor(Date.now() / 1000);
                        const stakingTime = stakeTimestamp.toNumber();
                        const timeStaked = currentTime - stakingTime;
                        
                        const daysStaked = timeStaked / 86400;
                        const hoursStaked = timeStaked / 3600;
                        
                        // Expected rewards calculations
                        const expectedDailyReward = stakeAmount * dailyRate;
                        const expectedRewardForTime = stakeAmount * dailyRate * daysStaked;
                        
                        console.log('ðŸ‘¤ User Stake Analysis:');
                        console.log(`  Staked Amount: ${stakeAmount} tokens`);
                        console.log(`  Staking Time: ${daysStaked.toFixed(4)} days (${hoursStaked.toFixed(2)} hours)`);
                        console.log(`  Actual Rewards: ${rewardAmount} tokens`);
                        console.log(`  Expected Daily Reward: ${expectedDailyReward.toFixed(8)} tokens`);
                        console.log(`  Expected Reward for Time Staked: ${expectedRewardForTime.toFixed(8)} tokens`);
                        
                        const accuracy = (rewardAmount / expectedRewardForTime) * 100;
                        console.log(`  Accuracy: ${accuracy.toFixed(2)}%`);
                        
                        // Detailed breakdown
                        console.log('ðŸ” Detailed Breakdown:');
                        console.log(`  Formula: StakeAmount Ã— DailyRate Ã— DaysStaked`);
                        console.log(`  Calculation: ${stakeAmount} Ã— ${dailyRate.toFixed(8)} Ã— ${daysStaked.toFixed(4)}`);
                        console.log(`  Result: ${expectedRewardForTime.toFixed(8)} tokens expected`);
                        
                        return {
                            contractAPY: apyPercent,
                            dailyRate: dailyRate,
                            stakeAmount: stakeAmount,
                            timeStakedDays: daysStaked,
                            actualRewards: rewardAmount,
                            expectedRewards: expectedRewardForTime,
                            accuracy: accuracy,
                            isAccurate: Math.abs(accuracy - 100) < 5 // Within 5% is considered accurate
                        };
                    } else {
                        console.log('âŒ User has no stake in this contract');
                        return {
                            contractAPY: apyPercent,
                            dailyRate: dailyRate,
                            hasStake: false
                        };
                    }
                } else {
                    console.log('â„¹ï¸ No user address provided - showing general APY info only');
                    return {
                        contractAPY: apyPercent,
                        dailyRate: dailyRate,
                        walletNotConnected: true
                    };
                }
                
            } catch (error) {
                console.error('âŒ Error verifying APY calculation:', error);
                showStatus('Error verifying APY: ' + error.message, 'error');
                return null;
            }
        }
        
        // COMPREHENSIVE TIME FRAME VERIFICATION - 100% Accuracy Test
        async function comprehensiveTimeTest(contractAddress) {
            if (!provider || !signer) {
                showStatus('Please connect wallet first', 'error');
                return;
            }

            try {
                console.log('ðŸ”¬ COMPREHENSIVE TIME FRAME TEST');
                console.log('='.repeat(50));
                
                const stakingContract = new ethers.Contract(contractAddress, STAKING_ABI, provider);
                const userAddress = await signer.getAddress();
                
                // Get contract time settings
                const lockPeriod = await stakingContract.lockPeriod();
                const lockPeriodDays = lockPeriod.toNumber() / 86400;
                
                console.log('ðŸ“Š CONTRACT TIME SETTINGS:');
                console.log(`  Lock Period: ${lockPeriod.toString()} seconds`);
                console.log(`  Lock Period: ${lockPeriodDays} days`);
                console.log(`  Lock Period: ${lockPeriod.toNumber() / 3600} hours`);
                console.log(`  Lock Period: ${lockPeriod.toNumber() / 60} minutes`);
                
                // Check if user has a stake
                const userStake = await stakingContract.userStakes(userAddress);
                const stakeTimestamp = await stakingContract.getStakeTimestamp(userAddress);
                
                if (userStake.eq(0) || stakeTimestamp.eq(0)) {
                    console.log('âŒ No stake found for verification');
                    return { error: 'No stake found' };
                }
                
                // Get current blockchain time vs JavaScript time
                const currentBlock = await provider.getBlockNumber();
                const blockInfo = await provider.getBlock(currentBlock);
                const blockTimestamp = blockInfo.timestamp;
                const jsTimestamp = Math.floor(Date.now() / 1000);
                
                console.log('â° TIMESTAMP COMPARISON:');
                console.log(`  Blockchain Time: ${blockTimestamp} (${new Date(blockTimestamp * 1000).toLocaleString()})`);
                console.log(`  JavaScript Time: ${jsTimestamp} (${new Date(jsTimestamp * 1000).toLocaleString()})`);
                console.log(`  Difference: ${Math.abs(blockTimestamp - jsTimestamp)} seconds`);
                
                // Calculate timing with blockchain timestamp (most accurate)
                const stakeTime = stakeTimestamp.toNumber();
                const timeStakedBlockchain = blockTimestamp - stakeTime;
                const timeStakedJS = jsTimestamp - stakeTime;
                
                console.log('ðŸ“… STAKING TIME ANALYSIS:');
                console.log(`  Stake Time: ${stakeTime} (${new Date(stakeTime * 1000).toLocaleString()})`);
                console.log(`  Time Staked (Blockchain): ${timeStakedBlockchain} seconds`);
                console.log(`  Time Staked (JavaScript): ${timeStakedJS} seconds`);
                console.log(`  Days Staked (Blockchain): ${(timeStakedBlockchain / 86400).toFixed(6)} days`);
                console.log(`  Hours Staked (Blockchain): ${(timeStakedBlockchain / 3600).toFixed(4)} hours`);
                console.log(`  Minutes Staked (Blockchain): ${(timeStakedBlockchain / 60).toFixed(2)} minutes`);
                
                // Calculate unlock time
                const unlockTime = stakeTime + lockPeriod.toNumber();
                const timeUntilUnlock = unlockTime - blockTimestamp;
                
                console.log('ðŸ”“ UNLOCK TIME ANALYSIS:');
                console.log(`  Unlock Time: ${unlockTime} (${new Date(unlockTime * 1000).toLocaleString()})`);
                console.log(`  Time Until Unlock: ${timeUntilUnlock} seconds`);
                console.log(`  Days Until Unlock: ${(timeUntilUnlock / 86400).toFixed(6)} days`);
                console.log(`  Hours Until Unlock: ${(timeUntilUnlock / 3600).toFixed(4)} hours`);
                
                // Check contract's fee calculation
                const canWithdrawWithoutFee = await stakingContract.canWithdrawWithoutFee(userAddress);
                
                console.log('ðŸ’° FEE STATUS:');
                console.log(`  Can Withdraw Without Fee: ${canWithdrawWithoutFee}`);
                console.log(`  Should be fee-free when: ${timeStakedBlockchain} >= ${lockPeriod.toNumber()}`);
                console.log(`  Condition met: ${timeStakedBlockchain >= lockPeriod.toNumber()}`);
                
                // CRITICAL TEST: Verify the exact math the contract uses
                console.log('ðŸ” CRITICAL VERIFICATION:');
                console.log(`  Contract Logic: current_time (${blockTimestamp}) - stake_time (${stakeTime}) >= lock_period (${lockPeriod.toNumber()})`);
                console.log(`  Calculation: ${blockTimestamp} - ${stakeTime} = ${timeStakedBlockchain}`);
                console.log(`  Test: ${timeStakedBlockchain} >= ${lockPeriod.toNumber()} = ${timeStakedBlockchain >= lockPeriod.toNumber()}`);
                console.log(`  Contract Result: ${canWithdrawWithoutFee}`);
                console.log(`  Results Match: ${(timeStakedBlockchain >= lockPeriod.toNumber()) === canWithdrawWithoutFee}`);
                
                // Test exact 1-day scenario
                if (lockPeriodDays === 1) {
                    console.log('ðŸ“Š 1-DAY SCENARIO VERIFICATION:');
                    console.log(`  Expected: 86400 seconds = 1 day`);
                    console.log(`  Contract: ${lockPeriod.toNumber()} seconds`);
                    console.log(`  Match: ${lockPeriod.toNumber() === 86400}`);
                    
                    const exactHoursStaked = timeStakedBlockchain / 3600;
                    console.log(`  Hours Staked: ${exactHoursStaked.toFixed(6)}`);
                    console.log(`  Should unlock at: 24.000000 hours`);
                    console.log(`  Currently unlocked: ${canWithdrawWithoutFee}`);
                }
                
                // Return comprehensive results
                const results = {
                    contractAddress,
                    lockPeriodSeconds: lockPeriod.toNumber(),
                    lockPeriodDays: lockPeriodDays,
                    stakeTimestamp: stakeTime,
                    blockchainTimestamp: blockTimestamp,
                    timeStakedSeconds: timeStakedBlockchain,
                    timeStakedDays: timeStakedBlockchain / 86400,
                    timeStakedHours: timeStakedBlockchain / 3600,
                    unlockTimestamp: unlockTime,
                    timeUntilUnlockSeconds: timeUntilUnlock,
                    canWithdrawWithoutFee,
                    contractMathCorrect: (timeStakedBlockchain >= lockPeriod.toNumber()) === canWithdrawWithoutFee,
                    isExact1Day: lockPeriod.toNumber() === 86400,
                    accuracyVerified: true
                };
                
                console.log('âœ… COMPREHENSIVE TEST COMPLETE');
                console.log('='.repeat(50));
                
                return results;
                
            } catch (error) {
                console.error('âŒ Error in comprehensive time test:', error);
                showStatus('Error in time verification: ' + error.message, 'error');
                return { error: error.message };
            }
        }
        
        // Quick test for 1-day contracts specifically  
        async function testOneDayContract(contractAddress) {
            console.log('ðŸŽ¯ TESTING 1-DAY CONTRACT SPECIFICALLY');
            
            const result = await comprehensiveTimeTest(contractAddress);
            
            if (result.error) return result;
            
            console.log('ðŸ“‹ 1-DAY CONTRACT SUMMARY:');
            console.log(`  Is exactly 1 day (86400s): ${result.isExact1Day}`);
            console.log(`  Time staked: ${result.timeStakedHours.toFixed(4)} hours`);
            console.log(`  Should unlock at: 24.0000 hours`);
            console.log(`  Currently fee-free: ${result.canWithdrawWithoutFee}`);
            console.log(`  Contract math correct: ${result.contractMathCorrect}`);
            
            const hoursRemaining = 24 - result.timeStakedHours;
            if (hoursRemaining > 0) {
                console.log(`  Hours remaining: ${hoursRemaining.toFixed(4)}`);
                console.log(`  Minutes remaining: ${(hoursRemaining * 60).toFixed(2)}`);
            } else {
                console.log(`  âœ… 24+ hours completed, should be fee-free!`);
            }
            
            return result;
        }
        
        // Make new functions globally available
        window.searchContracts = searchContracts;
        window.filterContracts = filterContracts;
        window.clearFilters = clearFilters;
        window.refreshDirectory = refreshDirectory;
        window.verifyTimePeriods = verifyTimePeriods;
        window.testOneDayPeriod = testOneDayPeriod;
        window.verifyContractTimePeriods = verifyContractTimePeriods;
        window.verifyAPYCalculation = verifyAPYCalculation;
        window.comprehensiveTimeTest = comprehensiveTimeTest;
        window.testOneDayContract = testOneDayContract;
        
        // Auto-search on input
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', function() {
                    clearTimeout(this.searchTimeout);
                    this.searchTimeout = setTimeout(searchContracts, 300);
                });
                
                // Change placeholder text on mobile
                function updatePlaceholder() {
                    if (window.innerWidth <= 480) {
                        searchInput.placeholder = 'Search';
                    } else {
                        searchInput.placeholder = 'Search by contract name, token symbol, or address...';
                    }
                }
                
                // Update on load and resize
                updatePlaceholder();
                window.addEventListener('resize', updatePlaceholder);
            }
        });
    </script>

    <!-- Wallet Modal - Positioned at body level for proper z-index -->
    <div id="walletModal" class="wallet-modal" style="display: none;">
        <div class="wallet-modal-content">
            <div class="wallet-modal-header">
                <h3>Connect Your Wallet</h3>
                <button class="close-modal" onclick="closeWalletModal()">Ã—</button>
            </div>
            <div class="wallet-options">
                <div class="mobile-notice">
                    <strong>Mobile Users:</strong> Open this page inside your wallet app's built-in browser for the best experience.
                </div>
                <button class="wallet-option" onclick="connectSpecificWallet('metamask')">
                    <span class="wallet-name">MetaMask</span>
                    <span class="wallet-desc">Connect with MetaMask wallet</span>
                </button>
                <button class="wallet-option" onclick="connectSpecificWallet('coinbase')">
                    <span class="wallet-name">Coinbase Wallet</span>
                    <span class="wallet-desc">Connect with Coinbase wallet</span>
                </button>
                <button class="wallet-option" onclick="connectSpecificWallet('trust')">
                    <span class="wallet-name">Trust Wallet</span>
                    <span class="wallet-desc">Connect with Trust wallet</span>
                </button>
                <button class="wallet-option" onclick="connectSpecificWallet('generic')">
                    <span class="wallet-name">Other Wallet</span>
                    <span class="wallet-desc">Connect with any Web3 wallet</span>
                </button>
            </div>
            <div class="mobile-instructions">
                <h4>Mobile Instructions:</h4>
                <ol>
                    <li>Copy this page URL</li>
                    <li>Open your wallet app (MetaMask, Trust Wallet, Coinbase Wallet, etc.)</li>
                    <li>Navigate to the built-in browser</li>
                    <li>Paste the URL and visit this page</li>
                    <li>Connect your wallet when prompted</li>
                </ol>
            </div>
        </div>
    </div>

    <!-- Admin Modals - Coinbase Wallet Compatible -->
    <!-- Deposit Rewards Modal -->
    <div id="depositRewardsModal" class="admin-modal" style="display: none;">
        <div class="admin-modal-content">
            <div class="admin-modal-header">
                <h3>Deposit Rewards</h3>
                <button class="admin-close-btn" onclick="closeAdminModal('depositRewardsModal')">&times;</button>
            </div>
            <div class="admin-info-box">
                <strong>Contract:</strong> <span id="depositContractAddress"></span><br>
                <strong>Reward Token:</strong> <span id="depositRewardToken"></span><br>
                <strong>Your Balance:</strong> <span id="depositUserBalance"></span><br>
                <strong>Contract Balance:</strong> <span id="depositContractBalance"></span>
            </div>
            <form id="depositRewardsForm">
                <div class="admin-form-group">
                    <label for="depositAmount">Amount to Deposit</label>
                    <input type="number" id="depositAmount" class="admin-input" placeholder="0.0" step="any" required>
                </div>
                <div class="admin-btn-group">
                    <button type="button" class="admin-btn secondary" onclick="closeAdminModal('depositRewardsModal')">Cancel</button>
                    <button type="submit" class="admin-btn primary">Deposit Rewards</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Withdraw Fees/Rewards Modal -->
    <div id="withdrawFeesModal" class="admin-modal" style="display: none;">
        <div class="admin-modal-content">
            <div class="admin-modal-header">
                <h3>Withdraw Fees/Rewards</h3>
                <button class="admin-close-btn" onclick="closeAdminModal('withdrawFeesModal')">&times;</button>
            </div>
            <div class="admin-info-box">
                <strong>Contract:</strong> <span id="feesContractAddress" class="mobile-address"></span><br>
                <strong>Available to Withdraw (Fees & Excess Rewards):</strong><br>
                <div id="availableWithdrawals" style="margin-top: 0.5rem; padding-left: 1rem;"></div>
            </div>
            <div class="admin-warning-box">
                <strong>Note:</strong> This withdraws only:<br>
                â€¢ Early withdrawal fees collected from users<br>
                â€¢ Excess reward tokens not distributed to stakers<br>
                â€¢ Excess tokens not owned by current stakers<br>
                â€¢ Does NOT withdraw user funds or active staking balances
            </div>
            <form id="withdrawFeesForm">
                <div class="admin-form-group">
                    <label for="feeTokenAddress">Token Address</label>
                    <input type="text" id="feeTokenAddress" class="admin-input" placeholder="0x0 for ETH, or paste token address" required>
                    <small style="color: var(--console-blue); font-size: 0.75rem;">ETH: 0x0 | Check available amounts above</small>
                </div>
                <div class="admin-form-group">
                    <label for="feeWithdrawAmount">Amount to Withdraw</label>
                    <input type="number" id="feeWithdrawAmount" class="admin-input" placeholder="0.0" step="any" required>
                    <small style="color: var(--console-amber); font-size: 0.75rem;">Only withdrawable amounts shown above</small>
                </div>
                <div class="admin-btn-group">
                    <button type="button" class="admin-btn secondary" onclick="closeAdminModal('withdrawFeesModal')">Cancel</button>
                    <button type="submit" class="admin-btn primary">Withdraw Fees/Rewards</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Transfer Ownership Modal -->
    <div id="transferOwnershipModal" class="admin-modal" style="display: none;">
        <div class="admin-modal-content">
            <div class="admin-modal-header">
                <h3>Transfer Ownership</h3>
                <button class="admin-close-btn" onclick="closeAdminModal('transferOwnershipModal')">&times;</button>
            </div>
            <div class="admin-warning-box">
                <strong>âš ï¸ WARNING: This action is IRREVERSIBLE!</strong><br><br>
                You are about to transfer ownership of this staking contract.<br>
                The new owner will have full control over all admin functions.<br>
                You will lose all admin privileges permanently.
            </div>
            <div class="admin-info-box">
                <strong>Contract:</strong> <span id="ownershipContractAddress"></span><br>
                <strong>Current Owner:</strong> <span id="currentOwner"></span>
            </div>
            <form id="transferOwnershipForm">
                <div class="admin-form-group">
                    <label for="newOwnerAddress">New Owner Address</label>
                    <input type="text" id="newOwnerAddress" class="admin-input" placeholder="0x..." pattern="^0x[a-fA-F0-9]{40}$" required>
                </div>
                <div class="admin-btn-group">
                    <button type="button" class="admin-btn secondary" onclick="closeAdminModal('transferOwnershipModal')">Cancel</button>
                    <button type="submit" class="admin-btn danger">Transfer Ownership</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Stake Confirmation Modal -->
    <div id="stakeConfirmModal" class="admin-modal" style="display: none;">
        <div class="admin-modal-content">
            <div class="admin-modal-header">
                <h3>Confirm Stake</h3>
                <button class="admin-close-btn" onclick="closeAdminModal('stakeConfirmModal')">&times;</button>
            </div>
            <div class="admin-info-box">
                <strong>Amount to Stake:</strong> <span id="confirmStakeAmount" class="mobile-amount"></span><br>
                <strong>Contract:</strong> <span id="confirmStakeContract" class="mobile-address"></span><br>
                <strong>Type:</strong> <span id="confirmStakeType" class="mobile-amount"></span><br><br>
                <div style="color: var(--console-amber); font-weight: bold;">
                    This transaction cannot be reversed
                </div>
            </div>
            <div class="admin-btn-group">
                <button type="button" class="admin-btn secondary" onclick="closeAdminModal('stakeConfirmModal')">Cancel</button>
                <button type="button" class="admin-btn primary" onclick="executeStake()">Confirm Stake</button>
            </div>
        </div>
    </div>

    <!-- Withdraw Confirmation Modal -->
    <div id="withdrawConfirmModal" class="admin-modal" style="display: none;">
        <div class="admin-modal-content">
            <div class="admin-modal-header">
                <h3>Confirm Withdrawal</h3>
                <button class="admin-close-btn" onclick="closeAdminModal('withdrawConfirmModal')">&times;</button>
            </div>
            <div class="admin-info-box">
                <strong>Amount to Withdraw:</strong> <span id="confirmWithdrawAmount" class="mobile-amount"></span><br>
                <strong>Your Staked Balance:</strong> <span id="confirmStakedBalance" class="mobile-amount"></span><br>
                <strong>Unlock Date:</strong> <span id="confirmUnlockDate" class="mobile-amount"></span><br>
                <strong>Early Withdrawal:</strong> <span id="confirmEarlyWithdraw" class="mobile-amount"></span><br>
                <div id="confirmWithdrawWarning" style="margin-top: 1rem;"></div>
            </div>
            <div class="admin-btn-group">
                <button type="button" class="admin-btn secondary" onclick="closeAdminModal('withdrawConfirmModal')">Cancel</button>
                <button type="button" class="admin-btn primary" onclick="executeWithdrawal()">Confirm Withdrawal</button>
            </div>
        </div>
    </div>

    <!-- Claim Rewards Confirmation Modal -->
    <div id="claimConfirmModal" class="admin-modal" style="display: none;">
        <div class="admin-modal-content">
            <div class="admin-modal-header">
                <h3>Claim Rewards</h3>
                <button class="admin-close-btn" onclick="closeAdminModal('claimConfirmModal')">&times;</button>
            </div>
            <div class="admin-info-box">
                <strong>Rewards to Claim:</strong> <span id="confirmClaimAmount" class="mobile-amount"></span><br>
                <strong>Contract:</strong> <span id="confirmClaimContract" class="mobile-address"></span>
            </div>
            <div class="admin-btn-group">
                <button type="button" class="admin-btn secondary" onclick="closeAdminModal('claimConfirmModal')">Cancel</button>
                <button type="button" class="admin-btn primary" onclick="executeClaimRewards()">Claim Rewards</button>
            </div>
        </div>
    </div>

    <!-- Emergency Withdraw Modal -->
    <div id="emergencyWithdrawModal" class="admin-modal" style="display: none;">
        <div class="admin-modal-content">
            <div class="admin-modal-header">
                <h3>Enable Emergency Withdraw</h3>
                <button class="admin-close-btn" onclick="closeAdminModal('emergencyWithdrawModal')">&times;</button>
            </div>
            <div class="admin-warning-box">
                <strong>EMERGENCY FUNCTION!</strong><br><br>
                This will enable emergency withdraw mode for ALL users.<br>
                Users will be able to withdraw their stake immediately without penalty.<br>
                This action should only be used in emergency situations.
            </div>
            <div class="admin-info-box">
                <strong>Contract:</strong> <span id="emergencyContractAddress"></span><br>
                <strong>Total Staked:</strong> <span id="emergencyTotalStaked"></span>
            </div>
            <div class="admin-btn-group">
                <button type="button" class="admin-btn secondary" onclick="closeAdminModal('emergencyWithdrawModal')">Cancel</button>
                <button type="button" class="admin-btn danger" onclick="confirmEmergencyWithdraw()">Enable Emergency Withdraw</button>
            </div>
        </div>
    </div>
</body>
</html>
